
<!DOCTYPE html>
<html>
<head>
    <title>uhv</title>
</head>
<body>
    <pre>
________________________________________________________________________________________________________________________


~ 1 ~ DATA STRUCTURES LAB PROGRAMS STACK:

1. Stack using Arrays Write a C program for the
  following operations on a stack of integers (use arrays).a) Push
    b) Pop c) Display
#include<stdio.h>
#include<stdlib.h>
#define SIZE 5
  int top = -1;
void push (int a[], int item)
{
  top = top + 1;
  a[top] = item;
}

int pop (int a[])
{
  int item;
  item = a[top];
  top = top - 1;
  return item;
}

void display (int a[])
{
  int i;
  if (top == -1)
    printf ("The stack is empty\n");
  else if (top != -1)
    {
      printf ("The stack elements are\n");
      for (i = top; i >= 0; i--)
	printf ("%d ", a[i]);
      printf ("\n");
    }
}

int main ()
{
  int s[10], choice, item;
  ~2 ~ while (1)
    {
      printf ("Enter the choice\n");
      printf ("1 Push\n2 Pop\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  if (top == SIZE - 1)
	    {
	      printf ("The stack is full\n");
	      break;
	    }
	  else
	    {
	      printf ("Enter the element to be pushed\n");
	      scanf ("%d", &item);
	      push (s, item);
	    }
	  break;
	case 2:
	  if (top == -1)
	    {
	      printf ("The stack is empty\n");
	      break;
	    }
	  item = pop (s);
	  printf ("Popped element is %d\n", item);
	  break;
	case 3:
	  display (s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

2.Stack - Structure Write a C program for the
  following operations on a stack of integers (use structure).a) Push b) Pop
    c) Display
#include<stdio.h>
#include<stdlib.h>~ 3 ~
#define MAX 10
    struct stack
  {
    int top;
    int items[MAX];
  };

void push (int, struct stack *);
void pop (struct stack *);
void display (struct stack *);
int main ()
{
  struct stack s;
  s.top = -1;
  int choice, item;
  for (;;)
    {
      printf ("Enter your choice\n");
      printf ("1 Push\n2 Pop\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the item\n");
	  scanf ("%d", &item);
	  push (item, &s);
	  break;
	case 2:
	  pop (&s);
	  break;
	case 3:
	  display (&s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

void push (int item, struct stack *s)
{
  if (s->top == MAX - 1)
    printf ("The stack is full\n");
  else
    {
      ~4 ~ (s->top)++;
      s->items[s->top] = item;
    }
}

void pop (struct stack *s)
{
  int item;
  if (s->top == -1)
    printf ("The stack is empty\n");
  else
    {
      item = s->items[s->top];
      (s->top)--;
      printf ("%d deleted\n", item);
    }
}

void display (struct stack *s)
{
  int t = s->top;
  if (s->top == -1)
    printf ("The stack is empty\n");
  else
    {
      printf ("Elements in the stack are\n");
      while (t > -1)
	{
	  printf ("%d ", s->items[t--]);
	}
      printf ("\n");
    }
}

3.String Palindrome using Stack
  Write a C program to check given a string is a palindrome or not using
  stack.
#include<stdio.h>
#include<stdlib.h>
#define max 30
char stack[max], c[max], d[max];
int top = -1, j = 0, k = 0;
char pop ();
~5 ~ void push (char);
int main ()
{
  char a[30], b[30], sym;
  int m = 0, i;
  printf ("Enter a string\n");
  gets (a);
  if (a[0] == '\0')
    printf ("Enter valid string\n");
  else
    {
      for (i = 0; a[i] != '\0'; i++)
	m++;
      for (i = 0; i < m; i++)
	{
	  sym = a[i];
	  push (sym);
	}
      for (i = 0; (i < m) && (top != -1); i++)
	b[i] = pop ();
      b[i] = '\0';
      d[k] = '\0';
      printf ("Reverse of given string is\n");
      printf ("%s\n", d);
      for (i = 0; b[i] != '\0'; i++)
	{
	  if (c[i] != b[i])
	    {
	      printf ("String is not a palindrome\n");
	      exit (0);
	    }
	}
      printf ("String is a palindrome\n");
    }
  return 0;
}

void push (char sym)
{
  if (top == max - 1)
    {
      ~6 ~ printf ("Stack is full\n");
      return;
    }
  top++;
  stack[top] = sym;
  if (sym != ' ')
    c[j++] = sym;
}

char pop ()
{
  if (top == -1)
    {
      printf ("Stack is empty\n");
      exit (0);
    }
  if (stack[top] == 32)
    d[k++] = stack[top--];
  d[k++] = stack[top];
  return (stack[top--]);
}

4.Infix to postfix Write a C program to convert and print a given valid parenthesized infix arithmetic expression to postfix expression.The expression consists of single character operands and +, -, *, /operators.Constraints:only four operators used +, -, *,
  /.
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<ctype.h>
#include<string.h>
#define max 100
#define TRUE 1
#define FALSE 0
  struct stack
{
  int top;
  char items[max];
};

struct stack s;
char infix[max], postfix[max];
~7 ~ int pos = 0;
void convert ();
void push (char);
char pop ();
int precedence (char);
int f = 0;
int empty ();
int stackfull ();
int main ()
{
  s.top = -1;
  printf ("Enter the infix expression\n");
  gets (infix);
  convert ();
  if (f == 0)
    {
      printf ("The postfix expression is\n");
      puts (postfix);
    }
  return 0;
}

void convert ()
{
  if (infix[0] == b \0 b  )
    {
      f = 1;
      printf (b Invalid input \ n b  );
      return;
    }
  int i;
  char symbol, temp;
  for (i = 0; infix[i] != '\0'; i++)
    {
      symbol = infix[i];
      switch (symbol)
	{
	case '(':
	  push (symbol);
	  break;
	case ')':
	  while ((temp = pop ()) != '(')
	    postfix[pos++] = temp;
	  break;
	case '+':
	case '-':
	case '*':
	~8 ~ case '/':
	case '$':
	  while (!empty ()
		 && precedence (s.items[s.top]) >= precedence (symbol)
		 && precedence (symbol) != -1)
	    {
	      temp = pop ();
	      postfix[pos++] = temp;
	    }
	  push (symbol);
	  break;
	default:
	  if (!isalpha (symbol))
	    {
	      printf ("Invalid input\n");
	      f = 1;
	      return;
	    }
	  else
	    {
	      postfix[pos++] = symbol;
	      break;
	    }
	}
    }
  while (!empty ())
    {
      temp = pop ();
      postfix[pos++] = temp;
    }
}

void push (char ele)
{
  if (stackfull ())
    printf ("Stack is full\n");
  else
    s.items[++s.top] = ele;
}

char pop ()
{
  if (empty ())
    {
      ~9 ~ printf ("Stack is empty\n");
      exit (0);
    }
  else
    return (s.items[s.top--]);
}

int stackfull ()
{
  if (s.top == max - 1)
    return TRUE;
  else
    return FALSE;
}

int empty ()
{
  if (s.top == -1)
    return TRUE;
  else
    return FALSE;
}

int precedence (char symbol)
{
  switch (symbol)
    {
    case '$':
      return 3;
    case '*':
    case '/':
      return 2;
    case '+':
    case '-':
      return 1;
    case '(':
    case ')':
      return (0);
    default:
      printf ("Invalid input\n");
      return -1;
    }
}

5.Suffix - Postfix
  Write a C program to evaluate a valid suffix /
  postfix expression using the stack.Assume that suffix /
  postfix expression is read as a single line consisting of non b  negative
  single digit operands and binary arithmetic operators.
  The arithmetic operators are +, -, /, *, ^, ($).
#include<stdio.h>
#include<stdlib.h>~ 10 ~
#include<ctype.h>
#include<math.h>
#include<string.h>
#define size 10
  struct stack
{
  int top;
  double item[size];
};

double op (char, double, double);
void push (char, struct stack *);
double pop (struct stack *);
int main ()
{
  int i;
  double op1, op2, res;
  struct stack s;
  s.top = -1;
  char postfix[20], sym;
  printf ("Enter the postfix expression\n");
  gets (postfix);
  for (i = 0; i < strlen (postfix); i++)
    {
      sym = postfix[i];
      if (isdigit (sym))
	push (sym, &s);
      else
	{
	  op2 = pop (&s);
	  op1 = pop (&s);
	  res = op (sym, op1, op2);
	  if (res == -9999)
	    {
	      printf ("Invalid input");
	      return 0;
	    }
	  s.item[++s.top] = res;
	}
    }
  res = s.item[s.top--];
  ~11 ~ printf ("Result after evaluation is %.2f", res);
  return 0;
}

void push (char sym, struct stack *s)
{
  s->top++;
  s->item[s->top] = sym - '0';
}

double pop (struct stack *s)
{
  double ele;
  ele = s->item[s->top];
  s->top--;
  return (ele);
}

double op (char sym, double op1, double op2)
{
  switch (sym)
    {
    case '+':
      return (op1 + op2);
    case '-':
      return (op1 - op2);
    case '*':
      return (op1 * op2);
    case '/':
      return (op1 / op2);
    case '&':
    case '^':
      return (pow (op1, op2));
    default:
      return -9999;
    }
  exit (0);
}

QUEUE:
6. Queue
  Write a C program to simulate the working of a queue of integers using
  structure.Provide the following operations i)
     Insert ii)
     Delete iii) Display
#include<stdio.h>
#include<stdlib.h>
#define MAX 5
     struct queue
     {
       int rear, front;
       ~12 ~ int q[MAX];
     };

void INSERT (int, struct queue *);
void DELETE (struct queue *);
void DISPLAY (struct queue *);
int main ()
{
  int choice, item;
  struct queue s;
  s.rear = -1;
  s.front = 0;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insertion\n2 Deletion\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  if (s.rear == MAX - 1)
	    printf ("Queue is full\n");
	  else
	    {
	      printf ("Enter the element to be inserted\n");
	      scanf ("%d", &item);
	      INSERT (item, &s);
	    }
	  break;
	case 2:
	  DELETE (&s);
	  break;
	case 3:
	  DISPLAY (&s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

void INSERT (int item, struct queue *s)
{
  s->rear = s->rear + 1;
  s->q[s->rear] = item;
} ~13 ~ void DELETE (struct queue *s)

{
  int item;
  if (s->front > s->rear)
    printf ("Queue is empty\n");
  else
    {
      item = s->q[s->front];
      printf ("%d deleted\n", item);
      (s->front)++;
    }
}

void DISPLAY (struct queue *s)
{
  int i;
  if (s->front > s->rear)
    printf ("Queue is empty\n");
  else
    {
      printf ("Elements in the queue are\n");
      for (i = s->front; i <= s->rear; i++)
	printf ("%d ", s->q[i]);
      printf ("\n");
    }
}

7.Circular Queue
  Write a C program to simulate the working of a circular queue of integers
  using array or structure.Provide the following operations.i)
     Insert ii)
     Delete iii) Display
#include<stdio.h>
#include<stdlib.h>
#define SIZE 3
     int items[SIZE];
     int front = -1, rear = -1;
     int isFull ()
     {
       if ((front == rear + 1) || (front == 0 && rear == SIZE - 1))
	 return 1;
       return 0;
     }

~14 ~ int isEmpty ()
{
  if (front == -1)
    return 1;
  return 0;
}

void insert ()
{
  int element;
  if (isFull ())
    printf ("Queue is full\n");
  else
    {
      printf ("Enter the element\n");
      scanf ("%d", &element);
      if (front == -1)
	front = 0;
      rear = (rear + 1) % SIZE;
      items[rear] = element;
    }
}

void delete ()
{
  int element;
  if (isEmpty ())
    printf ("Queue is empty\n");
  else
    {
      element = items[front];
      if (front == rear)
	{
	  front = -1;
	  rear = -1;
	}
      else
	front = (front + 1) % SIZE;
      printf ("Deleted element %d \n", element);
    }
}

void display ()
{
  int i;
  if (isEmpty ())
    ~15 ~ printf ("Queue is empty\n");
  else
    {
      printf ("Elements in the queue\n");
      for (i = front; i != rear; i = (i + 1) % SIZE)
	printf ("%d ", items[i]);
      printf ("%d \n", items[i]);
    }
}

int main ()
{
  int choice;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insertion\n2 Deletion\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  insert ();
	  break;
	case 2:
	  delete ();
	  break;
	case 3:
	  display ();
	  break;
	case 4:
	  exit (0);
	}
    }
}

8.Priority Queue Write a c program to design a priority queue.Provide the following operations:i)
     Insert ii)
     Delete iii) Display
#include<stdio.h>
#include<stdlib.h>
#define MAX 5
     int q[MAX];
     int front = 0, rear = -1, i, j;
     void insert ()
     {
       ~16 ~ printf ("Enter value\n");
       int ele;
       scanf ("%d", &ele);
       if (rear == MAX - 1)
	 printf ("Queue overflow\n");
       else
	 {
	   j = rear;
	   while ((j >= front) && (ele > q[j]))
	     {
	       q[j + 1] = q[j];
	       j--;
	     }
	   q[j + 1] = ele;
	   rear++;
	 }
     }

void delete ()
{
  int flag = 0;
  if (front > rear)
    printf ("There are no elements to delete\n");
  else
    {
      int ele;
      printf ("Enter value to delete\n");
      scanf ("%d", &ele);
      for (i = front; i <= rear; i++)
	{
	  if (q[i] == ele)
	    {
	      flag = 1;
	      for (j = i; j > front; j--)
		q[j] = q[j - 1];
	      front++;
	      break;
	    }
	}
      ~17 ~ if (flag == 0)
	printf ("%d not found\n", ele);
    }
}

void display ()
{
  if (front > rear)
    printf ("Queue is empty\n");
  else
    {
      for (i = front; i <= rear; i++)
	printf ("%d ", q[i]);
      printf ("\n");
    }
}

int main ()
{
  int ch;
  printf ("1 Insert\n2 Delete\n3 Display\n4 Exit\n");
  for (;;)
    {
      printf ("Enter your choice\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  insert ();
	  break;
	case 2:
	  delete ();
	  break;
	case 3:
	  display ();
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

~18 ~ SINGLY LINKED LIST:
9. Stack using Singly Linked List
  Write C program using dynamic variables and pointers to construct a singly
  Linked list to perform the operations of a stack of integers.(Push, Pop,
								Display).i)
     use Structure to create a node ii)
     make use of user - defined data type typedef.
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE X;
  X = (NODE) malloc (sizeof (struct node));
  return (X);
}

void freenode (NODE X)
{
  free (X);
}

NODE insert_front (NODE first, int item)
{
  NODE temp;
  temp = getnode ();
  temp->info = item;
  temp->link = first;
  return (temp);
}

NODE delete_front (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return first;
    }
  ~19 ~ temp = first;
  temp = temp->link;
  printf ("Deleted data is %d\n", first->info);
  freenode (first);
  return (temp);
}

void display (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  printf ("Contents of the Linked list are\n");
  temp = first;
  while (temp != NULL)
    {
      printf ("%d ", temp->info);
      temp = temp->link;
    }
  printf ("\n");
}

int main ()
{
  int choice, item;
  NODE first = NULL;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert rear\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the item\n");
	  scanf ("%d", &item);
	  first = insert_front (first, item);
	  break;
	case 2:
	  first = delete_front (first);
	  break;
	case 3:
	  display (first);
	  ~20 ~ break;
	case 4:
	  exit (0);
	}
    }
}

10. Queue using Singly Linked List
  Write a C program using dynamic variables and pointers to construct a singly
  Linked list to perform the operations of a queue of integers.
#include<stdio.h>
#include<stdlib.h>
  struct node
{
  int info;
  struct node *link;
};

typedef struct node *NODE;
NODE getnode ()
{
  NODE X;
  X = (NODE) malloc (sizeof (struct node));
  if (X == NULL)
    {
      printf ("Memeory not available\n");
    }
  return (X);
}

void freenode (NODE X)
{
  free (X);
}

NODE insert_rear (int item, NODE first)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  temp->link = NULL;
  if (first == NULL)
    return (temp);
  cur = first;
  ~21 ~ while (cur->link != NULL)
    {
      cur = cur->link;
    }
  cur->link = temp;
  return (first);
}

NODE delete_front (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return (first);
    }
  temp = first;
  temp = temp->link;
  printf ("Deleted data is %d\n", first->info);
  freenode (first);
  return (temp);
}

void display (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  printf ("Contents of the Linked list are\n");
  temp = first;
  while (temp != NULL)
    {
      printf ("%d ", temp->info);
      temp = temp->link;
    }
  printf ("\n");
}

~22 ~ int main ()
{
  int choice, item;
  NODE first = NULL;
  for (;;)
    {
      printf ("Enter your choice");
      printf ("\n1 Insert rear\n2 Delete front\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &item);
	  first = insert_rear (item, first);
	  break;
	case 2:
	  first = delete_front (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

11. Singly Linked List - Dynamic
  Write a C program using dynamic variables and pointers to construct a singly
  linked list consisting of the following information in each node:student
  id (integer), student name (character string)
     and semester (integer).The operations to be supported are:i)
     Insert at specified position ii)
     Delete front iii) Display
#include<stdio.h>
#include<stdlib.h>
     int count = 0;
     struct node
     {
       int student_id;
       int semester;
       char student_name[20];
       struct node *link;
     ~23 ~};

void insert (struct node **s, int pos)
{
  int i;
  if (pos > count + 1)
    {
      printf ("Invalid position\n");
      return;
    }
  struct node *newnode;
  newnode = (struct node *) malloc (sizeof (struct node));
  printf ("Enter id\n");
  scanf ("%d", &(newnode->student_id));
  printf ("Enter name\n");
  scanf ("%s", newnode->student_name);
  printf ("Enter semester\n");
  scanf ("%d", &(newnode->semester));
  struct node *temp = *s;
  if ((*s) == NULL)
    {
      (*s) = newnode;
      count++;
    }
  e lse if (pos == 0 || pos == 1)
    {
      count++;
      newnode->link = *s;
      *s = newnode;
    }
  else
    {
      for (i = 2; i < pos; i++)
	{
	  temp = temp->link;
	}
      newnode->link = temp->link;
      temp->link = newnode;
      count++;
    }
}

~24 ~ void delete_front (struct node **s)
{
  if ((*s) == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  struct node *temp = *s;
  struct node *cur = temp->link;
  *s = cur;
  int item = temp->student_id;
  free (temp);
  printf ("Deleted ID is %d\n", item);
}

void display (struct node *s)
{
  if (s == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  struct node *temp = s;
  printf ("Contents are\n");
  while (temp != NULL)
    {
      printf ("ID %d\n", temp->student_id);
      printf ("Name %s\n", temp->student_name);
      printf ("Semester %d\n", temp->semester);
      temp = temp->link;
    }
}

int main ()
{
  int choice, pos;
  struct node *s = NULL;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert at position\n2 Delete front\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      ~25 ~ switch (choice)
	{
	case 1:
	  printf ("Enter the position\n");
	  scanf ("%d", &pos);
	  insert (&s, pos);
	  break;
	case 2:
	  delete_front (&s);
	  break;
	case 3:
	  display (s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

12. Circular Linked List
  Write a C program to support the following operations on a circular linked
  list where each node consists of integers.1. Insert rear 2. Delete rear 3.
  Display.
#include<stdio.h>
#include<stdlib.h>
  struct node
{
  int data;
  struct node *link;
};

typedef struct node *NODE;
NODE insert_rear (NODE first, int item)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->data = item;
  if (first == NULL)
    {
      first = newnode;
      first->link = newnode;
      ~26 ~ return first;
    }
  else
    {
      NODE temp = first;
      while (temp->link != first)
	temp = temp->link;
      temp->link = newnode;
      newnode->link = first;
      return first;
    }
}

NODE delete_rear (NODE first)
{
  if (first == NULL)
    {
      printf ("List is empty\n");
      return first;
    }
  else
    {
      int itm;
      NODE temp = first;
      if (first->link == first)
	{
	  itm = first->data;
	  free (temp);
	  first = NULL;
	}
      else
	{
	  NODE prev = NULL;
	  while (temp->link != first)
	    {
	      prev = temp;
	      temp = temp->link;
	    }
	  prev->link = first;
	  itm = temp->data;
	  ~27 ~ free (temp);
	}
      printf ("Deleted data is %d\n", itm);
      return first;
    }
}

void display (NODE first)
{
  if (first == NULL)
    {
      printf ("List is empty");
      return;
    }
  else
    {
      NODE temp;
      temp = first;
      printf ("Contents of the Circular Linked list are\n");
      while (temp->link != first)
	{
	  printf ("%d ", temp->data);
	  temp = temp->link;
	}
      printf ("%d", temp->data);
    }
}

int main ()
{
  int choice, val;
  NODE first = NULL;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert rear\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  first = insert_rear (first, val);
	  ~28 ~ break;
	case 2:
	  first = delete_rear (first);
	  break;
	case 3:
	  display (first);
	  printf ("\n");
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

DOUBLY LINKED LIST:13. Doubly linked list
  Write a C program to support the following operations on a doubly linked
  list where each node consists of integers.i)
     Insert front ii)
     Delete rear iii) Display.
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE insert_front (NODE first, int val)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->info = val;
  newnode->llink = NULL;
  if (first == NULL)
    {
      first = newnode;
      newnode->rlink = NULL;
      return first;
    }
  else
    {
      newnode->rlink = first;
      ~29 ~ first->llink = newnode;
      return newnode;
    }
}

NODE delete_rear (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return first;
    }
  int del;
  NODE cur = first;
  if (first->rlink == NULL)
    {
      del = first->info;
      free (first);
      first = NULL;
    }
  else
    {
      NODE prev = NULL;
      while (cur->rlink != NULL)
	{
	  cur = cur->rlink;
	}
      prev = cur->llink;
      prev->rlink = NULL;
      del = cur->info;
      free (cur);
    }
  printf ("Deleted data is %d\n", del);
  return first;
}

void display (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return;
    }
  ~30 ~
  else
    {
      NODE temp = first;
      while (temp != NULL)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
      printf ("\n");
    }
}

int main ()
{
  NODE first = NULL;
  int choice, val;
  while (1)
    {
      printf
	("Enter your choice\n1 Insert front\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  first = insert_front (first, val);
	  break;
	case 2:
	  first = delete_rear (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

14. Circular Doubly Linked List I
  Write a C program to support the following operations on a circular doubly
  linked list (with or without header node where each node consists of
	       integers.i)
     Insert front ii)
     Delete rear iii) Display. ~ 31 ~
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE insert_front (NODE first, int val)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->info = val;
  if (first == NULL)
    {
      first = newnode;
      newnode->llink = newnode;
      newnode->rlink = newnode;
      return first;
    }
  else
    {
      NODE last = first->llink;
      newnode->rlink = first;
      newnode->llink = last;
      last->rlink = newnode;
      first->llink = newnode;
      return newnode;
    }
}

NODE delete_rear (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return first;
    }
  int del;
  NODE cur = first;
  ~32 ~ if (first->rlink == first)
    {
      del = first->info;
      free (first);
      first = NULL;
    }
  else
    {
      NODE prev = NULL;
      cur = first->llink;
      prev = cur->llink;
      prev->rlink = first;
      first->llink = prev;
      del = cur->info;
      free (cur);
    }
  printf ("Deleted data is %d\n", del);
  return first;
}

void display (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return;
    }
  else
    {
      NODE temp = first;
      while (temp->rlink != first)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
      printf ("%d \n", temp->info);
    }
}

int main ()
{
  NODE first = NULL;
  int choice, val;
  ~33 ~ while (1)
    {
      printf
	("Enter your choice\n1 Insert front\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  first = insert_front (first, val);
	  break;
	case 2:
	  first = delete_rear (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

15. Circular doubly linked list II
  Write a C program to support the following operations on a circular doubly
  linked list (with or without header node)
     where each node consists of integers.i)
     Insert rear ii)
     Delete front iii)
     Insert Right iv) Display
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE insert_rear (NODE head, int val)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->info = val;
  if (head->rlink == head)
    ~34 ~
    {
      head->rlink = newnode;
      head->llink = newnode;
      newnode->llink = head;
      newnode->rlink = head;
      return head;
    }
  else
    {
      NODE temp = head->llink;
      temp->rlink = newnode;
      newnode->llink = temp;
      newnode->rlink = head;
      head->llink = newnode;
      return head;
    }
}

NODE delete_front (NODE head)
{
  int del;
  NODE temp = head->rlink;
  if (head->rlink == head)
    {
      printf ("List is empty\n");
      return head;
    }
  else
    {
      NODE next = temp->rlink;
      head->rlink = next;
      next->llink = head;
      del = temp->info;
      free (temp);
      printf ("%d deleted\n", del);
      return head;
    }
}

void display (NODE head)
{
  if (head->rlink == head)
    ~35 ~
    {
      printf ("List is empty\n");
      return;
    }
  else
    {
      printf ("Contents of the Circular Doubly Linked list are\n");
      NODE temp = head->rlink;
      while (temp != head)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
      printf ("\n");
    }
}

NODE insert_right (NODE head, int key, int val)
{
  NODE temp = head->rlink;
  while (temp != head)
    {
      if (temp->info == key)
	break;
      temp = temp->rlink;
    }
  if (temp == head)
    {
      printf ("Key not found\n");
      return head;
    }
  else
    {
      NODE newnode;
      newnode = (NODE) malloc (sizeof (struct node));
      newnode->info = val;
      NODE next = temp->rlink;
      temp->rlink = newnode;
      newnode->llink = temp;
      newnode->rlink = next;
      next->llink = newnode;
      ~36 ~ return head;
    }
}

int main ()
{
  NODE head = (NODE) malloc (sizeof (struct node));
  head->info = 0;
  head->rlink = head;
  head->llink = head;
  int choice, val, key;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert rear\n2 Delete front\n3 Insert right\n4 Display\n5 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  head = insert_rear (head, val);
	  break;
	case 2:
	  head = delete_front (head);
	  break;
	case 3:
	  printf ("Enter the key\n");
	  scanf ("%d", &key);
	  printf ("Enter a node\n");
	  scanf ("%d", &val);
	  head = insert_right (head, key, val);
	  break;
	case 4:
	  display (head);
	  break;
	case 5:
	  exit (0);
	  break;
	default:
	  printf ("Invalid input\n");
	}
    }
  return 0;
}

~37 ~ TREES:
16. Binary Tree
  Write a C program to implement a binary tree of integers and perform the
  following traversal techniques.i) In - order traversal ii) Post -
  order traversal iii) Pre - order traversal.
#include<stdio.h>
#include<stdlib.h>
  struct node
{
  int info;
  struct node *lchild;
  struct node *rchild;
};

typedef struct node *NODE;
NODE create_B_Tree ()
{
  NODE newnode;
  int data = 0;
  newnode = NULL;
  printf ("Enter data ('0' if no data)");
  scanf ("%d", &data);
  if (data)
    {
      newnode = (NODE) malloc (sizeof (struct node));
      newnode->info = data;
      printf ("\nLeft child of %d\n", newnode->info);
      newnode->lchild = create_B_Tree ();
      printf ("\nRight child of %d\n", newnode->info);
      newnode->rchild = create_B_Tree ();
    }
  return newnode;
}

void pre_order (NODE root)
{
  if (root != NULL)
    {
      printf ("%d\n", root->info);
      pre_order (root->lchild);
      pre_order (root->rchild);
    ~38 ~}
}

void post_order (NODE root)
{
  if (root != NULL)
    {
      post_order (root->lchild);
      post_order (root->rchild);
      printf ("%d\n", root->info);
    }
}

void in_order (NODE root)
{
  if (root != NULL)
    {
      in_order (root->lchild);
      printf ("%d\n", root->info);
      in_order (root->rchild);
    }
}

int main ()
{
  printf ("Create binary tree, start from root\n");
  NODE root;
  root = create_B_Tree ();
  while (1)
    {
      printf ("Select mode of traversal for displaying the binary tree\n");
      printf ("1 Pre-order\n2 Post-order\n3 In-order\n4 Exit\nChoice \n");
      int choice;
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  pre_order (root);
	  printf ("\n");
	  break;
	case 2:
	  post_order (root);
	  printf ("\n");
	  break;
	case 3:
	  in_order (root);
	  ~39 ~ printf ("\n");
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

17.Ex pression Tree
  Write a C program to construct expression tree for the given postfix
  expression and evaluate the same.
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#define max 100
  struct node
{
  int data;
  struct node *llink, *rlink;
};

typedef struct node *NODE;
NODE construct_tree (char postfix[max])
  {
    if (postfix[0] == b \0 b  )
      return NULL;
    char sym;
    NODE newnode, stack[max];
    int i, top = -1;
    for (i = 0; postfix[i] != '\0'; i++)
      {
	sym = postfix[i];
	newnode = (NODE) malloc (sizeof (struct node));
	newnode->data = sym;
	newnode->llink = NULL;
	newnode->rlink = NULL;
	if (isdigit (sym))
	  {
	    stack[++top] = newnode;
	    continue;
	  }
	switch (sym)
	  {
	  ~40 ~ case '+':
	  case '-':
	  case '*':
	  case '/':
	    newnode->rlink = stack[top--];
	    newnode->llink = stack[top--];
	    stack[++top] = newnode;
	    break;
	  default:
	    return NULL;
	  }
      }
    return stack[top--];
  }

float evaluate (NODE root)
{
  switch (root->data)
    {
    case '+':
      return (evaluate (root->llink) + evaluate (root->rlink));
    case '-':
      return (evaluate (root->llink) - evaluate (root->rlink));
    case '*':
      return (evaluate (root->llink) * evaluate (root->rlink));
    case '/':
      return (evaluate (root->llink) / evaluate (root->rlink));
    default:
      return (root->data - '0');
    }
}

int main ()
{
  float res;
  char postfix[max];
  NODE root = NULL;
  printf ("Enter the postfix expression\n");
  gets (postfix);
  root = construct_tree (postfix);
  if (root == NULL)
    {
      printf ("Invalid input\n");
      return 0;
    }
  res = evaluate (root);
  printf ("Result after evaluation is %.2f\n", res);
  return 0;
}

~41 ~ 18. Binary - Search Tree Write a C program to implement a binary search tree of integers and perform the following traversal techniques:
i) In - order traversal
  ii)
     Find the maximum element iii)
     Search an element
       Display "Duplication is not allowed" if same element is inserted
       again.Display "Key element not found" if searched element is not
       present in the tree.Display "Search is successful" if searched element
       is present in the tree.Displpay "Maximum element is 15" if the maximum
       element is 15 in the tree.
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int data;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE create_node (int val)
  {
    NODE newnode;
    newnode = (NODE) malloc (sizeof (struct node));
    newnode->data = val;
    newnode->llink = NULL;
    newnode->rlink = NULL;
    return newnode;
  }
void setleft (NODE p, int val)
{
  if (p == NULL)
    printf ("Insertion is not possible\n");
  else if (p->llink != NULL)
    printf ("Invalid insertion\n");
  else
    p->llink = create_node (val);
}

void setright (NODE p, int val)
{
  if (p == NULL)
    printf ("Insertion is not possible\n");
  else if (p->rlink != NULL)
    ~42 ~ printf ("Invalid insertion\n");
  else
    p->rlink = create_node (val);
}

NODE create_BS_Tree (NODE root, int val)
{
  if (root == NULL)
    {
      root = create_node (val);
    }
  else
    {
      NODE p, q;
      p = q = root;
      while (val != p->data && q != NULL)
	{
	  p = q;
	  if (val < p->data)
	    q = p->llink;
	  else
	    q = p->rlink;
	}
      if (val == p->data)
	{
	  printf ("Duplication is not allowed\n");
	}
      else if (val < p->data)
	setleft (p, val);
      else
	setright (p, val);
    }
  return root;
}

void inorder (NODE root)
{
  if (root != NULL)
    {
      inorder (root->llink);
      printf ("%d ", root->data);
      ~43 ~ inorder (root->rlink);
    }
}

void search (NODE root, int key)
{
  NODE p, q;
  p = q = root;
  while (key != p->data && q != NULL)
    {
      p = q;
      if (key < p->data)
	q = p->llink;
      else
	q = p->rlink;
    }
  if (key == p->data)
    printf ("Search is successful\n");
  else
    printf ("Key element not found\n");
}

int maximum (NODE root)
{
  while (root->rlink != NULL)
    {
      root = root->rlink;
    }
  return root->data;
}

int main ()
{
  int choice, val, key, max;
  NODE root = NULL;
  printf ("1 Insert\n2 In-order\n3 Search\n4 Maximum\n5 Exit\n");
  while (1)
    {
      printf ("Enter your Choice\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	~44 ~ case 1:
	  printf ("Enter the element\n");
	  scanf ("%d", &val);
	  root = create_BS_Tree (root, val);
	  break;
	case 2:
	  inorder (root);
	  printf ("\n");
	  break;
	case 3:
	  printf ("Enter the element to be searched\n");
	  scanf ("%d", &key);
	  search (root, key);
	  break;
	case 4:
	  max = maximum (root);
	  printf ("Maximum element is %d\n", max);
	  break;
	case 5:
	  exit (0);
	  break;
	default:
	  printf ("Invalid choice\n");
	}
    }
  return 0;
  ***


















_______________________________________________________________________________________________________________

DS LAB PROGRAMS:01)
     Implement stack operations such as Push,
       Pop and Display using arrays /
       global variables.
       The program should print appropriate messages for stack overflow and
       stack underflow
#include <stdio.h>
#include <stdlib.h>
#define MAX 3
     int top = -1
       , stack[MAX];
     void push ();
     void pop ();
     void display ();
     void main ()
     {
       int ch;
       while (1)
	 {
	   printf ("\n***Stack Menu***");
	   printf ("\n\n1.Push\n2.Pop\n3.Display\n4.Exit");
	   printf ("\n\nEnter your choice(1-4): ");
	   scanf ("%d", &ch);
	   switch (ch)
	     {
	     case 1:
	       push ();
	       break;
	     case 2:
	       pop ();
	       break;
	     case 3:
	       display ();
	       break;
	     case 4:
	       exit (0);
	     default:
	       printf ("\nWrong CHoice!!");
	     }
	 }
     }

void push ()
{
  int val;
  if (top == MAX - 1)
    {
      printf ("\nStack is full!!");
    }
  else
    {
      printf ("\nEnter element to push:");
      scanf ("%d", &val);
      top = top + 1;
      stack[top] = val;
    }
}

void pop ()
{
  if (top == -1)
    {
      printf ("\nStack is empty");
    }
  else
    {
      printf ("\nDeleted element is %d", stack[top]);
      top = top - 1;
    }
}

void display ()
{
  int i;
  if (top == -1)
    {
      printf ("STACK IS EMPTY\n");
    }
  else
    {
      printf ("\nStack is ....\n");
      for (i = top; i >= 0; --i)
	printf ("%d\n", stack[i]);
    }
}

02)
     Convert a given valid parenthesized infix arithmetic expression to
       postfix expression.
       The expression consists of single character operands and +, -, *,
       /operators.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
     int F (char symbol)
     {
       switch (symbol)
	 {
	 case '+':
	 case '-':
	   return 2;
	 case '*':
	 case '/':
	   return 4;
	 case '^':
	 case '$':
	   return 5;
	 case '(':
	   return 0;
	 case '#':
	   return -1;
	 default:
	   return 8;
	 }
     }

int G (char symbol)
{
  switch (symbol)
    {
    case '+':
    case '-':
      return 1;
    case '*':
    case '/':
      return 3;
    case '^':
    case '$':
      return 6;
    case '(':
      return 9;
    case ')':
      return 0;
    default:
      return 7;
    }
}

void infix_postfix (char infix[], char postfix[])
{
  int top;
  int j;
  int i;
  char s[30];
  char symbol;
  top = -1;
  s[++top] = '#';
  j = 0;
  for (i = 0; i < strlen (infix); i++)
    {
      symbol = infix[i];
      while (F (s[top]) > G (symbol))
	{
	  postfix[j] = s[top--];
	  j++;
	}
      if (F (s[top]) != G (symbol))
	s[++top] = symbol;
      else
	top--;
    }
  while (s[top] != '#')
    {
      postfix[j++] = s[top--];
    }
  postfix[j] = '\0';
}

int main ()
{
  char infix[20], postfix[20];
  printf ("ENTER AN INFIX EXPRESSION\n");
  scanf ("%s", infix);
  infix_postfix (infix, postfix);
  printf ("POSTFIX EXPRESSION IS %s", postfix);
  return 0;
}

03)
     Evaluate a valid suffix /
       postfix expression using stack.Assume that suffix /
       postfix expression is read as a single line consisting of non negative
       single digit operands and binary arithmetic operators.
       The arithmetic operators are +, -, /, *, ^($).
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
     double compute (char symbol, double op1, double op2)
     {
       switch (symbol)
	 {
	 case '+':
	   return op1 + op2;
	 case '-':
	   return op1 - op2;
	 case '/':
	   return op1 / op2;
	 case '*':
	   return op1 * op2;
	 case '^':
	 case '$':
	   return pow (op1, op2);
	 default:
	   printf ("invalid operation\n");
	   exit (0);
	 }
     }

int main ()
{
  double s[20], op1, op2, res;
  int top, i;
  char postfix[20], symbol;
  printf ("enter the postfix expression\n");
  scanf ("%s", postfix);
  top = -1;
  for (i = 0; i < strlen (postfix); i++)
    {
      symbol = postfix[i];
      if (isdigit (symbol))
	s[++top] = symbol - '0';
      else
	{
	  op2 = s[top--];
	  op1 = s[top--];
	  res = compute (symbol, op1, op2);
	  s[++top] = res;
	}
    }
  res = s[top--];
  printf ("the result is=%f\n", res);
  return 0;
}

04)
     Find if a given string is a palindrome or not using stack.
#include <stdio.h>
#include <stdlib.h>
#define MAX 50
     int i, top = -1
       , f = 0;
     char s[MAX];
     char a[MAX];
     void push (char);
     char pop ();
     int main ()
     {
       printf ("enter the expression\n");
       scanf ("%s", a);
       for (i = 0; a[i] != '\0'; i++)
	 {
	   push (a[i]);
	 }
       for (i = 0; a[i] != '\0'; i++)
	 {
	   if (a[i] != pop ())
	     {
	       f = 1;
	       break;
	     }
	 }
       if (f == 0)
	 {
	   printf ("it is a palindrome\n");
	 }
       else
	 {
	   printf ("it is not a palindrome\n");
	 }
     }

void push (char ch)
{
  top++;
  s[top] = ch;
}

char pop ()
{
  char x = s[top];
  top--;
  return x;
}

05)
     Implement Queue operations such as Insert, Delete and Display.Display
       appropriate messages on Queue overflow and Queue underflow conditions.
#include <stdio.h>
#include <stdlib.h>
#define que_size 4
     int rear, front, item, q[10];
     void insertq ()
     {
       if (rear == que_size - 1)
	 printf ("Queue Overflow\n");
       else
	 {
	   rear = rear + 1;
	   q[rear] = item;
	 }
     }

int delq ()
{
  if (front > rear)
    return -1;
  else
    return (q[front++]);
}

void display ()
{
  int i;
  if (front > rear)
    printf ("Queue Underflow\n");
  else
    {
      for (i = front; i <= rear; i++)
	{
	  printf ("%d\t\n", q[i]);
	}
    }
}

int main ()
{
  int ch, delitem;
  front = 0;
  rear = -1;
  while (1)
    {
      printf ("1.Insert 2.Delete 3.Display 4.Exit\n");
      printf ("Enter your Choice\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("Enter the Item\n");
	  scanf ("%d", &item);
	  insertq ();
	  break;
	case 2:
	  delitem = delq ();
	  if (delitem == -1)
	    printf ("Queue Underflow\n");
	  else
	    printf ("Deleted item= %d\n", delitem);
	  break;
	case 3:
	  display ();
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("Invalid choice!!try again\n");
	  break;
	}
    }
  return 0;
}

06)
     Implement Circular queue operations such as Insert,
       Delete and Display.
       Display appropriate messages on Queue overflow and Queue underflow
       conditions.
#include <stdio.h>
#include <stdlib.h>
#define que_size 5
     int rear, front, count, item, q[10];
     void insertq ()
     {
       if (count == que_size)
	 {
	   printf ("Queue is full\n");
	   return;
	 }
       rear = (rear + 1) % que_size;
       q[rear] = item;
       count++;
     }

int deleteq ()
{
  if (count == 0)
    return -1;
  item = q[front];
  front = (front + 1) % que_size;
  count -= 1;
  return item;
}

void displayq ()
{
  int i, f;
  if (count == 0)
    {
      printf ("queue is empty\n");
      return;
    }
  else
    for (i = 1, f = front; i <= count; i++)
      {
	printf ("%d\n", q[f]);
	f = (f + 1) % que_size;
      }
}

int main ()
{
  int ch, delitem;
  front = 0;
  rear = -1;
  while (1)
    {
      printf ("1.INSERT 2.DELETE 3.DISPLAY 4.EXIT\n");
      printf ("ENTER YOUR CHOICE\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("Enter the Item:");
	  scanf ("%d", &item);
	  insertq ();
	  break;
	case 2:
	  delitem = deleteq ();
	  if (delitem == -1)
	    printf ("Queue Underflow");
	  else
	    printf ("Deleted Item is %d\n", delitem);
	  break;
	case 3:
	  displayq ();
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("Invalid Choice");
	  break;
	}
    }
  return 0;
}

07)
     Implement Priority queue operations such as Insert, Delete and
       Display.Display appropriate messages on Queue overflow and
       Queue underflow conditions.
#include <stdio.h>
#include <stdlib.h>
#define qsize 3
     void insert (int item, int q[], int *r)
     {
       int j;
       if (*r == qsize - 1)
	 {
	   printf ("QUEUE OVERFLOW\n");
	   return;
	 }
       j = *r;
       while (j >= 0 && item < q[j])
	 {
	   q[j + 1] = q[j];
	   j--;
	 }
       q[j + 1] = item;
       *r = *r + 1;
     }

void display (int *r, int *f, int q[])
{
  int i;
  if (*f > *r)
    printf ("QUEUE IS EMPTY\n");
  else
    {
      for (i = *f; i <= *r; i++)
	printf ("%d ", q[i]);
    }
  printf ("\n");
}

int delete (int *f, int *r, int q[])
{
  if (*f > *r)
    return -1;
  else
    return (q[(*f)++]);
}

int main ()
{
  int front, rear, ch, delitm, item, q[5];
  front = 0;
  rear = -1;
  while (1)
    {
      printf ("ENTER YOUR CHOICE\n");
      printf ("1.INSERT 2.DELETE 3.DISPLAY 4.EXIT\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  insert (item, q, &rear);
	  break;
	case 2:
	  delitm = delete (&front, &rear, q);
	  if (delitm == -1)
	    printf ("QUEUE UNDERFLOW\n");
	  else
	    printf ("DELETED ITEM =%d\n", delitm);
	  break;
	case 3:
	  display (&rear, &front, q);
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("INVALID CHOICE !!TRY AGAIN \n");
	  break;
	}
    }
  return 0;
}

08)
     Implement Insert, Delete and Display operations on Singly Linked List.
#include <stdio.h>
#include <stdlib.h>
#include<ctype.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMEORY \n");
      exit (0);
    }
  return x;
}

NODE insertfront (int item, NODE first)
{
  NODE temp;
  temp = getnode ();
  temp->info = item;
  temp->link = first;
  return temp;
}

void display (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return;
    }
  printf ("THE CONTENTS ARE\n");
  temp = first;
  while (temp != NULL)
    {
      printf ("%d\t", temp->info);
      temp = temp->link;
    }
  printf ("\n");
}

NODE delfront (NODE first)	//FUNCTION TO DELETE FIRST NODE
{
  NODE temp;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return first;
    }
  temp = first;
  first = first->link;
  printf ("DELETED ITEM =%d\n", temp->info);
  free (temp);
  return first;
}

NODE insertrear (int item, NODE first)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  temp->link = NULL;
  if (first == NULL)
    {
      return temp;
    }
  cur = first;
  while (cur->link != NULL)
    {
      cur = cur->link;
    }
  cur->link = temp;
  return first;
}

NODE delrear (NODE first)
{
  NODE cur, prev;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return first;
    }
  if (first->link == NULL)
    {
      printf ("DELETED ITEM IS %d\n", first->info);
      free (first);
      first = NULL;
      return first;
    }
  prev = NULL;
  cur = first;
  while (cur->link != NULL)
    {
      prev = cur;
      cur = cur->link;
    }
  printf ("DELETED ITEM %d\n", cur->info);
  free (cur);
  prev->link = NULL;
  return first;
}

NODE insertpos (int item, int pos, NODE first)
{
  NODE temp, prev, cur;
  int counter;
  temp = getnode ();
  temp->info = item;
  temp->link = NULL;
  if (first == NULL && pos == 1)
    return temp;
  if (first == NULL)
    {
      printf ("INVALID POSITION\n");
      return first;
    }
  if (pos == 1)
    {
      temp->link = first;
      return temp;
    }
  counter = 1;
  prev = NULL;
  cur = first;
  while (cur != NULL && counter != pos)
    {
      prev = cur;
      cur = cur->link;
      counter++;
    }
  if (counter == pos)
    {
      prev->link = temp;
      temp->link = cur;
      return first;
    }
  else
    printf ("INVALID POSITION\n");
  return first;
}

NODE delinfo (int item, NODE first)
{
  NODE prev, cur;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return NULL;
    }
  if (item == first->info)
    {
      cur = first;
      first = first->link;
      free (cur);
      return first;
    }
  prev = NULL;
  cur = first;
  while (cur != NULL && item != cur->info)
    {
      prev = cur;
      cur = cur->link;
    }
  if (cur == NULL)
    {
      printf ("ITEM NOT FOUND\n");
      return first;
    }
  prev->link = cur->link;
  free (cur);
  return first;
}

NODE delpos (int pos, NODE first)
{
  NODE cur, prev;
  int counter;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return NULL;
    }
  if (pos == 1)
    {
      cur = first;
      first = first->link;
      free (cur);
      return first;
    }
  prev = NULL;
  cur = first;
  counter = 1;
  while (cur != NULL && counter != pos)
    {
      prev = cur;
      cur = cur->link;
      counter++;
    }
  if (cur == NULL)
    {
      printf ("INVALID POSITION\n");
      return first;
    }
  else
    prev->link = cur->link;
  free (cur);
  return first;
}

void search (int item, NODE first)
{
  NODE cur;
  int pos;
  if (first == NULL)
    {
      printf ("LIST EMPTY\n");
      return;
    }
  cur = first;
  pos = 1;
  while (cur != NULL && item != cur->info)
    {
      cur = cur->link;
      pos++;
    }
  if (cur == NULL)
    {
      printf ("SEARCH UNSUCCESSFUL");
      return;
    }
  printf ("SEARCH SUCCESSFUL &ITEM FOUND AT %d\n", pos - 1);
}

int main ()
{
  NODE first = NULL;
  int ch, item, pos;
  pos = 0;
  while (1)
    {
      printf ("ENTER YOUR CHOICE\n");
      printf ("1.INSERT AT FRONT END\n2.INSERT AT REAR END\n3.DELETE
AT FRONT END\n");
      printf ("4.DELETE AT REAR END\n5.INSERT AT SPECIFIED POSITION\
n");
      printf ("6.DELETE A PARTICULAR ELEMENT\n");
      printf ("7.DELETE AT SPECIFIED POSITION\n");
      printf ("8.SEARCH FOR A PARTICULAR ELEMENT\n");
      printf ("9.DISPLAYING THE LINKED LIST\n");
      printf ("10.EXIT\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ELEMENT\n");
	  scanf ("%d", &item);
	  first = insertfront (item, first);
	  break;
	case 2:
	  printf ("ENTER THE ELEMENT\n");
	  scanf ("%d", &item);
	  first = insertrear (item, first);
	  break;
	case 3:
	  first = delfront (first);
	  break;
	case 4:
	  first = delrear (first);
	  break;
	case 5:
	  printf ("ENTER THE ITEM TO BE INSERTED\n");
	  scanf ("%d", &item);
	  printf ("ENTER THE POSITION OF INSERTION\n");
	  scanf ("%d", &pos);
	  first = insertpos (item, pos, first);
	  break;
	case 6:
	  printf ("ENTER THE ELEMENT TO BE DELETED\n");
	  scanf ("%d", &item);
	  first = delinfo (item, first);
	  break;
	case 7:
	  printf ("ENTER THE POSITION OF DELETION\n");
	  scanf ("%d", &pos);
	  first = delpos (pos, first);
	  break;
	case 8:
	  printf ("ENTER THE SEARCH ELEMENT\n");
	  scanf ("%d", &item);
	  search (item, first);
	  break;
	case 9:
	  display (first);
	  break;
	case 10:
	  exit (0);
	default:
	  printf ("WRONG CHOICE!!TRY AGAIN\n");
	}
    }
  return 0;
}


09)
     Implement stack / queue operations using linked list.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("\nOUT OF MEMORY");
      exit (0);
    }
  return x;
}

NODE insert_front (int item, NODE first)
{
  NODE temp;
  temp = getnode ();
  temp->info = item;
  temp->link = first;
  return temp;
}

void display (NODE first)
{
  NODE cur;
  if (first == NULL)
    {
      printf ("\nLIST IS EMPTY");
      return;
    }
  printf ("\nThe contents of list are:\n");
  cur = first;
  while (cur != NULL)
    {
      printf ("%d\n", cur->info);
      cur = cur->link;
    }
  printf ("\n");
}

NODE delete_front (NODE first)
{
  NODE cur;
  if (first == NULL)
    {
      printf ("\nLIST IS EMPTY");
      return first;
    }
  cur = first;
  cur = cur->link;
  printf ("\nDELETED ITEM:%d", first->info);
  free (first);
  return cur;
}

int main ()
{
  NODE first;
  first = NULL;
  int op, item;
  while (1)
    {
      printf ("\n1.INSERT AT THE FRONT END \n2.DELETE AT THE FRONT
END");
      printf ("\n3.DISPLAY \n4.EXIT");
      printf ("\nENTER YOUR OPTION:");
      scanf ("%d", &op);
      switch (op)
	{
	case 1:
	  printf ("Enter the item to be inserted:");
	  scanf ("%d", &item);
	  first = insert_front (item, first);
	  break;
	case 2:
	  first = delete_front (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("\nWRONG OPTION");
	}
    }
  return 0;
}

10)
     Implement Insert, Delete and Display operations on circular
       Singly Linked List with header node.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMORY\n");
      exit (0);
    }
  return x;
}

NODE insert_front (int item, NODE head)
{
  NODE temp, first;
  temp = getnode ();
  temp->info = item;
  first = head->link;
  head->link = temp;
  temp->link = first;
  return head;
}

NODE insert_rear (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  cur = head->link;
  while (cur->link != head)
    {
      cur = cur->link;
    }
  cur->link = temp;
  temp->link = head;
  return head;
}

NODE delete_rear (NODE head)
{
  NODE prev, cur;
  if (head->link == head)
    {
      printf ("List is empty\n");
      return head;
    }
  cur = head->link;
  prev = head;
  while (cur->link != head)
    {
      prev = cur;
      cur = cur->link;
    }
  prev->link = head;
  printf ("The item deleted is %d\n", cur->info);
  free (cur);
  return head;
}

NODE delete_front (NODE head)
{
  NODE first, second;
  if (head->link == head)
    {
      printf ("List is empty\n");
      return head;
    }
  first = head->link;
  second = first->link;
  head->link = second;
  printf ("The item deleted is %d\n", first->info);
  free (first);
  return head;
}

void display (NODE head)
{
  NODE temp;
  {
    if (head->link == head)
      {
	printf ("List is empty\n");
	return;
      }
    printf ("The contents of singly linked listl\n");
    temp = head->link;
    while (temp != head)
      {
	printf ("%d ", temp->info);
	temp = temp->link;
      }
  }
}

void main ()
{
  NODE head;
  int choice, item;
  head = getnode ();
  head->link = head;
  for (;;)
    {
      printf ("1:Insert_Front 2:insert_rear\t");
      printf ("3:delete_front\t 4:delete_rear\t 5.exit\n");
      printf ("Enter the choice\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the item to be inserted in\n");
	  scanf ("%d", &item);
	  head = insert_front (item, head);
	  break;
	case 2:
	  printf ("Enter the item to be inserted in\n");
	  scanf ("%d", &item);
	  head = insert_rear (item, head);
	  break;
	case 3:
	  head = delete_front (head);
	  break;
	case 4:
	  head = delete_rear (head);
	  break;
	case 5:
	  display (head);
	  break;
	default:
	  exit (0);
	}
    }
}

12)
     Implement Insert, Delete and Display operations on Doubly Linked List.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *rlink;
       struct node *llink;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMORY\n");
      exit (0);
    }
  return x;
}

NODE insertfront (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == NULL)
    {
      head->rlink = temp;
      temp->llink = head;
      temp->rlink = NULL;
      head->llink = NULL;
      return head;
    }
  else
    {
      cur = head->rlink;
      temp->rlink = cur;
      head->rlink = temp;
      cur->llink = temp;
      temp->llink = head;
      return head;
    }
}

NODE insertrear (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == NULL)
    {
      head->rlink = temp;
      head->llink = NULL;
      temp->rlink = NULL;
      temp->llink = head;
      return head;
    }
  cur = head->rlink;
  while (cur->rlink != NULL)
    {
      cur = cur->rlink;
    }
  cur->rlink = temp;
  temp->rlink = NULL;
  temp->llink = cur;
  head->llink = NULL;
  return head;
}

NODE delfront (NODE head)
{
  NODE temp, cur;
  if (head->rlink == NULL)
    {
      printf ("LIST IS EMPTY \n");
      return head;
    }
  temp = head->rlink;
  cur = temp->rlink;
  if (cur == NULL)
    {
      head->rlink = NULL;
    }
  else
    {
      head->rlink = cur;
      cur->llink = head;
    }
  printf ("DELETED ITEM =%d\n", temp->info);
  free (temp);			//FREEING MEMORY
  return head;
}

NODE delrear (NODE head)
{
  NODE temp, cur;
  if (head->rlink == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return head;
    }
  else
    {
      temp = head->rlink;
      while (temp->rlink != NULL)
	{
	  temp = temp->rlink;
	}
      if (temp->llink == head)
	head->rlink = NULL;
      else
	{
	  cur = temp->llink;
	  cur->rlink = NULL;
	  head->llink = NULL;
	}
      printf ("DELETED ITEM =%d\n", temp->info);
      free (temp);
      return head;
    }
}

void display (NODE head)
{
  NODE temp;
  if (head->rlink == NULL)
    {
      printf ("LIST IS EMPTY\n");
    }
  else
    {
      temp = head->rlink;
      while (temp != NULL)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
    }
  printf ("\n");
}

int main ()
{
  int ch, item;
  NODE head = getnode ();
  head->info = NULL;
  head->rlink = NULL;
  head->llink = NULL;
  while (1)
    {
      printf
	("1.Insert Front 2.Insert Rear 3.Delete Front 4.Delete Rear 5.Display
6.Exit\n");
      printf ("ENTER YOUR CHOICE\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertfront (item, head);
	  break;
	case 2:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertrear (item, head);
	  break;
	case 3:
	  head = delfront (head);
	  break;
	case 4:
	  head = delrear (head);
	  break;
	case 5:
	  display (head);
	  break;
	case 6:
	  exit (0);
	  break;
	default:
	  printf ("INVALID CHOICE!!TRY AGAIN\n");
	  break;
	}
    }
  return 0;
}

12 Implement Insert, Delete and Display operations on Circular Doubly Linked
  List.
#include <stdio.h> #include
< stdlib.h > struct node
{
  int info;
  struct node *rlink;
  struct node *llink;
};

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMORY\n");
      exit (0);
    }
  return x;
}

NODE insertfront (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == head)
    {
      head - >rlink = temp;
      temp->llink = head;
      temp->rlink = head;
      head->llink = temp;
      return head;
    }
  else
    {
      cur = head->rlink;
      temp - >rlink = cur;
      head->rlink = temp;
      cur->llink = temp;
      temp->llink = head;
      return head;
    }
}

NODE insertrear (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == head)
    {
      head->rlink = temp;
      head->llink = temp;
      temp->rlink = head;
      temp->llink = head;
      return head;
    }
  cur = head - >llink;
  cur - >rlink = temp;
  temp - >rlink = head;
  temp - >llink = cur;
  head->llink = temp;
  return head;
}

NODE delfront (NODE head)
{
  NODE temp, cur;
  if (head->rlink == head)
    {
      printf ("LIST IS EMPTY \n");
      return head;
    }
  temp = head->rlink;
  cur = temp->rlink;
  if (cur == head)
    {
      head->rlink = head;
    }
  else
    {
      head->rlink = cur;
      cur->llink = head;
    }
  printf ("DELETED ITEM =%d\n", temp->info);
  free (temp);
  return head;
}

NODE delrear (NODE head)
{
  NODE temp, cur;
  if (head->rlink == head)
    {
      printf ("LIST IS
EMPTY\n");
      return head;
    }
  else
    {
      temp = head->llink;
      if (temp->llink == head)
	head->rlink = head;
      else
	{
	  cur = temp->llink;
	  cur->rlink = head;
	  head->llink = cur;
	}
      printf ("DELETED ITEM =%d\n", temp->info);
      free (temp);
      return head;
    }
}

void display (NODE head)
{
  NODE temp;
  if (head->rlink == head)
    {
      printf ("LIST IS EMPTY\n");
    }
  else
    {
      temp = head->rlink;
      while (temp != head)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
    }
  printf ("\n");
}

int main ()
{
  int ch, item;
  NODE head = getnode ();
  head->info = NULL;
  head->rlink = head;
  head->llink = head;
  while (1)
    {
      printf
	("1.Insert Front 2.Insert Rear 3.Delete Front 4.Delete Rear 5.Display 6.Exit\n");
      printf ("ENTER YOUR CHOICE\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertfront (item, head);
	  break;
	case 2:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertrear (item, head);
	  break;
	case 3:
	  head = delfront (head);
	  break;
	case 4:
	  head = delrear (head);
	  break;
	case 5:
	  display (head);
	  break;
	case 6:
	  exit (0);
	  break;
	default:
	  printf ("INVALID CHOICE!!TRY AGAIN\n");
	  break;
	}
    }
  return 0;
}

13)
     Construct a Binary Search Tree and traverse it using In order,
       Preorder and Post order traversals.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *left;
       struct node *right;
     };

typedef struct node *NODE;
NODE insert (NODE r, int item)
{
  if (r == NULL)
    {
      r = (NODE) malloc (sizeof (struct node));
      r->info = item;
      r->left = NULL;
      r->right = NULL;
    }
  else if (item < r->info)
    r->left = insert (r->left, item);
  else
    r->right = insert (r->right, item);
  return r;
}

void preorder (NODE root)
{
  if (root == NULL)
    return;
  printf ("%d ", root->info);
  preorder (root->left);
  preorder (root b right);
}

void inorder (NODE root)
{
  if (root == NULL)
    return;
  inorder (root->left);
  printf ("%d ", root->info);
  Inorder (root->right);
}

void postorder (NODE root)
{
  if (root == NULL)
    return;
  postorder (root->left);
  postorder (root->right);
  printf ("%d ", root->info);
}

NODE search (NODE root, int item)
{
  NODE cur;
  if (root == NULL)
    {
      printf ("EMPTY TREE\n");
      return;
    }
  else
    {
      cur = root;
      while (cur != NULL)
	{
	  if (item == cur->info)
	    return cur->info;
	  else if (item < cur->info)
	    cur = cur->left;
	  else
	    cur = cur->right;
	}
      return NULL;
    }
}

int main ()
{
  int ch, item, i, n, it, temp;
  NODE root;
  root = (NODE) malloc (sizeof (struct node));
  root = NULL;
  while (1)
    {
      printf
	("\n1.Insert 2.Preorder 3.Postorder 4.Inorder 5.Search 6.Exit\n");
      printf ("\nEnter The Choice\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE NO OF ELEMENTS\n");
	  scanf ("%d", &n);
	  for (i = 0; i < n; i++)
	    {
	      printf ("Enter The Item %d\n", i + 1);
	      scanf ("%d", &item);
	      root = insert (root, item);
	    }
	  break;
	case 2:
	  preorder (root);
	  break;
	case 3:
	  postorder (root);
	  break;
	case 4:
	  inorder (root);
	  break;
	case 5:
	  printf ("ENTER THE ELEMENT TO BE SEARCHED\n");
	  scanf ("%d", &it);
	  temp = search (root, it);
	  if (temp == NULL)
	    printf ("SEARCH UNSUCCESSFULL\n");
	  else
	    printf ("%d is found in the tree\n", temp);
	  break;
	case 6:
	  exit (0);
	  break;
	default:
	  printf ("WRONG CHOICE!! TRY AGAIN\n");
	}
    }
  return 0;
}

 </pre>
</body>
</html>
