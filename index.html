
<!DOCTYPE html>
<html>
<head>
    <title>uhv</title>
</head>
<body>
    <pre>
_______________________________________________
________________________________________________

1. Design, Develop and Implement a menu driven Program in C for the following
a) To create an Array of N Integer Elements and store n values.
● Inserting an Element (ELEM) at a given valid Position (POS)
● Deleting an Element at a given valid Position POS)
● Display of Array Elements
● Exit.
Support the program with functions for each of the above operations.
#include < stdio.h>
#include < stdlib.h>
int a[20],elem,pos;
int n=0;
void create();
void insert();
void delete();
void display();
int main()
{
int ch;
while(1)
{
printf("\n enter ypur choice:");
printf("\n 1.create\n 2.insert\n 3.delete\n 4.display\n 5.exit\n");
scanf("%d",&ch);
switch(ch)
{
case 1:create();
break;
case 2:insert();
break;
case 3:delete();
break;
case 4:display();
break;
case 5:exit(0);
default:printf("\n invalid choice");
}
Subject Code: CS2001-1 Subject Title: Data Structures
Chapter Number: Chapter Title: Practical’s
PlannedHours:02 per Experiments
}
}
void create()
{
printf("\n enter the number of elements:");
scanf("%d",&n);
printf("\n enter the elements:");
for(int i=0;i< n;i++)
{
scanf("%d",&a[i]);
}
}
void display()
{
if(n==0)
{
printf("\n no elements to be display ");
return;
}
printf("\n array elements are:");
for(int i=0;i< n;i++)
{
printf("%d\t",a[i]);
}
}
void insert()
{
if(n==20)
{
printf("array is full");
return;
}
printf("\n enter the position you want to enter:");
scanf("%d",&pos);
if(pos< 0||pos>n)
{
printf("\n invalid position");
}
else
{
printf("\n enter the element u want to insert:");
scanf("%d",&elem);
for(int i=n-1;i>=pos;i--)
{
a[i+1]=a[i];
}
a[pos]=elem;
n=n+1;
display();
}
}
void delete()
{ if(n==0)
{
printf("\n array is empty");
return;
}
else
{
printf("\n enter a position u want to delete the element:");
scanf("%d",&pos);
if(pos< 0||pos>=n)
{
printf("\n invalid position");
}
else
{
elem=a[pos];
printf("\n delete item is %d",elem);
for(int i=pos;i< n-1;i++)
{
a[i]=a[i+1];
}
n=n-1;
display();
}
}
}
b ) To create student structure with fields Roll No, Name, Semester, marks in 3 subjects. And
Write functions to
● Enter 5 students’ details and display the same using pointer to structure
● Find Student wise and subject wise total marks and display the same.
#include < stdio.h>
#include < stdlib.h>
struct student {
int rollno;
char name[20];
int sem;
float m1;
float m2;
float m3;
};
void enter5studentdetail(struct student *s) {
int i;
for (i = 0; i < 5; i++) {
printf("Enter the details of student %d\n", i + 1);
printf("Enter the roll number: ");
scanf("%d", &(s + i)->rollno);
printf("Enter the name of student: ");
scanf("%s", (s + i)->name);
printf("Enter the semester: ");
scanf("%d", &(s + i)->sem);
printf("Enter the marks in subject 1: ");
scanf("%f", &(s + i)->m1);
printf("Enter the marks in subject 2: ");
scanf("%f", &(s + i)->m2);
printf("Enter the marks in subject 3: ");
scanf("%f", &(s + i)->m3);
}
}
void display(struct student *s) {
int i;
for (i = 0; i < 5; i++) {
printf("\nDetails of student %d\n", i + 1);
printf("Roll number: %d\n", (s + i)->rollno);
printf("Name: %s\n", (s + i)->name);
printf("Semester: %d\n", (s + i)->sem);
printf("Marks in subject 1: %.2f\n", (s + i)->m1);
printf("Marks in subject 2: %.2f\n", (s + i)->m2);
printf("Marks in subject 3: %.2f\n", (s + i)->m3);
}
}
void studenttotal(struct student *s) {
int i;
float totalmarks;
for (i = 0; i < 5; i++) {
totalmarks = (s + i)->m1 + (s + i)->m2 + (s + i)->m3;
printf("Total marks of student %d: %.2f\n", i + 1, totalmarks);
}
}
void subjectwisetotmarks(struct student *s) {
float totalm1 = 0, totalm2 = 0, totalm3 = 0;
int i;
for (i = 0; i < 5; i++) {
totalm1 += (s + i)->m1;
totalm2 += (s + i)->m2;
totalm3 += (s + i)->m3;
}
printf("Total subject marks in subject 1: %.2f\n", totalm1);
printf("Total subject marks in subject 2: %.2f\n", totalm2);
printf("Total subject marks in subject 3: %.2f\n", totalm3);
}
int main() {
struct student s[5];
int choice;
while (1) {
printf("\nEnter the choice\n");
printf("1. Enter 5 student details\n2. Display\n3. Student total\n4. Subject-
wise total marks\n5. Exit\n");
scanf("%d", &choice);
switch (choice) {
case 1:
enter5studentdetail(s);
break;
case 2:
display(s);
break;
case 3:
studenttotal(s);
break;
case 4:
subjectwisetotmarks(s);
break;
case 5:
exit(0);
default:
printf("Invalid choice\n");
break;
}
}
return 0;
}
2. Design, Develop and Implement a menu driven Program in C for the following operations on
a ) STACK of Integers (Array with structure Implementation of Stack with size MAX)
● Push an Element on to Stack.
● Pop an Element from Stack.
● Demonstrate Overflow and Underflow situations on Stack.
● Display the status of Stack .
● Exit
#include < stdio.h>
#include < stdlib.h>
#define max 3
struct stack {
int top;
int q[max];
}s;
int main()
{
int choice,value;
s.top=-1;
while(1)
{
printf("enter your choice \n");
printf("1.insert \n2.delete \n3.display \n4.exit \n");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("enter the value you want to insert\n");
scanf("%d",&value);
insert(&s,value);
break;
case 2:
deletion(&s);
break;
case 3:
display(&s);
break;
case 4: exit(0);
}
}
return 0;
}
void insert(struct stack *s,int value)
{
if(s->top == max-1)
{
printf("stack is full \n");
}
else
{
(s->top)++;
s->q[s->top]=value;
printf("insertion is successful \n");
}
}
void deletion(struct stack *s)
{
if(s->top==-1)
{
printf("stack is empty \n");
}
else
{
printf("deleted element is %d \n",s->q[s->top]);
(s->top)--;
}
}
void display(struct stack *s)
{
if(s->top==-1)
{
printf("stack is empty \n");
}
else
{
printf("contents of stacks are \n");
for(int i = 0; i<=s->top;i++)
{
printf("%d \n",s->q[i]);
}
}
}
3. Queue of Integers (Array with structure Implementation of Queue with size MAX)
● Insert an Element in to Queue.
● Delete an Element from Queue.
● Demonstrate Overflow and Underflow situations on Queue.
● Display the status of Queue .
● Exit
Support the program with appropriate functions for each of the above operations
#include < stdio.h>
#include < stdlib.h>
#define max 5
//simple queue it is
struct queue
{
int rear;
int front;
int q[max];
}s;
int main()
{
int choice,value;
s.rear= -1;
s.front = 0;
while(1)
{
printf("enter the choice \n");
printf("1.insert \n 2.delete \n 3.display \n 4.exit \n");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("enter the value you want to insert");
scanf("%d",&value);
insert(&s,value);
break;
case 2:
del(&s);
break;
case 3:
display(&s);
break;
case 4:
exit(0);
}
}
return 0;
}
void insert(struct queue *s , int value)
{
if(s->rear == max-1)
{
printf("queue is full");
}
else{
(s->rear)++;
s->q[s->rear] = value;
}
}
void del(struct queue *s)
{
if(s->front> s->rear)
{
printf("queue is empty");
}
else
{
printf("deleted item is %d", s->q[s->front]);
(s->front)++;
}
}
void display(struct queue *s)
{
int count = 0;
if(s->front> s-> rear)
{
printf("queue is empty \n");
}
else
{ printf("elements are \n");
for(int i=s->front;i<= s-> rear;i++)
{
count ++;
printf("%d \n",s->q[i] );
}
printf("number of elements is %d \n",count);
}
}
4. Design, Develop and Implement a Program in C for the following Stack Applications
● Evaluation of Suffix expression with single digit operands and operators: +, -, *, /, %,
^ b
#include < stdio.h>
#include < stdlib.h>
#include< string.h>
#include< ctype.h>
#include< math.h>
#define MAX 5
struct stack
{
int top;
int item[MAX];
};
double op(char, double, double);
void push (char,struct stack *);
double pop(struct stack *);
int main()
{
struct stack s;
s.top=-1;
char sym,postfix[30];
double op1,op2,res;
printf("\n enter the postfix exp");
gets(postfix);
for(int i=0;i< strlen(postfix);i++)
{
sym=postfix[i];
if(isdigit(sym))
push(sym,&s);
else
{
op2=pop(&s);
op1=pop(&s);
res=op(sym,op1,op2);
if(res==-9999)
{
printf("invalid input");
return 0;
}
s.item[++s.top]=res;
}
}
res=s.item[s.top--];
printf("\n result is %.2f",res);
return 0;
}
void push(char sym,struct stack *s)
{
s->top++;
s->item[s->top]=sym-'0';
}
double pop(struct stack *s)
{
double elem;
elem=s->item[s->top];
s->top--;
return elem;
}
double op(char sym,double op1,double op2)
{
switch(sym)
{
case '+':return (op1+op2);
case '-':return (op1-op2);
case '*':return (op1*op2);
case '/':return (op1/op2);
case '$':
case '^':return (pow(op1,op2));
default:return -9999;
}
exit(0);
}
5. Design, Develop and Implement a Program in C for converting an Infix Expression to Postfix
Expression. Program should support for both parenthesized and free parenthesized
expressions with the operators: +, -, *, /, % (Remainder), ^ (Power) and alphanumeric
operands
#include< stdio.h>
#include< stdlib.h>
#include< string.h>
int F(char symbol)
{
switch(symbol)
{
case '-':
case '+':return 2;
case '*':
case '/':return 4;
case '$':
case '^':return 5;
case ' (':return 0;
case '#':return -1;
default:return 8;
}
}
int G(char symbol)
{
switch(symbol)
{
case '-':
case '+':return 1;
case '*':
case '/':return 3;
case '$':
case '^':return 6;
case '(':return 9;
case ')':return 0;
default:return 7;
}
}
void infix_postfix(char infix[],char postfix[])
{
int top=-1,j=0,i;
char s[30],symbol;
s[++top]='#';
for(i=0;i< strlen(infix);i++)
{
symbol=infix[i];
while(F(s[top])>G(symbol))
{
postfix[j]=s[top--];
j++;
}
if(F(s[top])!=G(symbol))
{
s[++top]=symbol;
}
else
{
top--;
}
}
while(s[top] != '#')
{
postfix[j++]=s[top--];
}
postfix[j]='\0';
}
void main()
{
char infix[20],postfix[20];
printf("\n enter the infix expression:");
scanf("%s",infix);
infix_postfix(infix,postfix);
printf("\n the postfix expression is :");
printf("%s",postfix);
}
6. Design, Develop and Implement a menu driven Program in C for the following operations on
Circular QUEUE of Characters (Array Implementation of Queue with maximum size MAX)
● Insert an Element on to Circular QUEUE.
● Delete an Element from Circular QUEUE.
● Demonstrate Overflow and Underflow situations on Circular QUEUE d. Display the
status of Circular QUEUE.
● Exit
Support the program with appropriate functions for each of the above operations
#include < stdio.h>
#include < stdlib.h>
#define max 5
int rear = -1;
int front = 0;
int a[max];
int count = 0;
int i;
void insert(int value)
{
if(count ==max)
{
printf("queue is full");
}
else
{
rear = rear +1%max;
count++;
a[rear] = value;
printf("insertion is successful");
}
}
void delete()
{
if(count == 0)
{
printf("queue is empty nothing to delete");
}
else
{
count--;
front = front + 1%max;
printf("deleted value is %d", a[front]);
}
}
void display() {
if(count == 0) {
printf("queue is empty\n");
}
else {
int j = front;
for (i = 0; i < count; i++) {
printf("%d ", a[j]);
j = (j + 1) % max; // Move to the next element in the circular queue
}
printf("\n");
}
}
int main()
{
int choice,value;
while(1)
{
printf("enter the choice \n");
printf("1.insert \n2.delete \n3.display \n4.exit \n");
scanf("%d",&choice);
switch (choice)
{
case 1 : printf("enter the value you want to
insert");scanf("%d",&value);insert(value);break;
case 2: delete(); break;
case 3:display(); break;
case 4: exit(0);
default : printf("invalid bsdk");
}
}
return 0;
}
7. Design, Develop and Implement a menu driven Program in C for the following operations on
Singly Linked List (SLL) for data of integers.
● Create a SLL of Data using front insertion.
● Display the status of SLL and count the number of nodes in it.
● Demonstration of stack
● Demonstration of Queue.
● Exit
#-----Demonstration of Stack using SLL-----#
#include < stdio.h>
#include < stdlib.h>
struct node
{
int info;
struct node *link;
};
typedef struct node *NODE;
NODE getnode()
{
NODE X;
X= (NODE)malloc(sizeof(struct node));
if(X== NULL)
{
printf("NOI MEM SPACE");
}
return(X);
}
void freenode(NODE X)
{
free(X);
}
NODE insertfront(NODE first, int value)
{
NODE temp;
temp =getnode();
temp-> info = value;
temp->link=NULL;
if(first==NULL)
return(temp);
temp->link= first;
return (temp);
}
NODE deletefront(NODE first)
{
NODE temp;
if(first==NULL)
{
printf("stack is empty \n");
}
temp=first;
printf("delted element is %d \n",first->info);
freenode(first);
return(temp);
}
void display( NODE first)
{
NODE cur;
if(first==NULL)
printf("stack is empty");
if(first->link==NULL)
printf("%d",first->info);
else
{
printf("contents are : \n");
cur=first;
while(cur!=NULL)
{
printf("%d",cur->info);
cur=cur->link;
}
}
}
int main()
{
int choice,value;
NODE first = NULL;
while(1)
{
printf("enter your choice \n");
printf("1.insert \n 2.delete \n 3.display \n 4.exit \n");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("enter the value you want to insert");
scanf("%d", &value);
first = insertfront(first,value);
break;
case 2:
first= deletefront(first); break;
case 3:
display(first);break;
case 4:
exit(0);
}
}
return 0;
}
#------Demonstration of Queue using SLL-----#
#include < stdio.h>
#include < stdlib.h>
#define MAX 5
struct node
{
int info;
struct node *link;
};
typedef struct node*NODE;
NODE getnode()
{
NODE x;
x=(NODE)malloc(sizeof(struct node));
return x;
}
void freenode(NODE x)
{
free(x);
}
NODE insertrear(NODE first,int item)
{
NODE temp,cur;
temp=getnode();
temp->info=item;
temp->link=NULL;
if(first==NULL)
return temp;
cur=first;
while(cur->link!=NULL)
{
cur=cur->link;
}
cur->link=temp;
return first;
}
NODE deletefront(NODE first)
{
NODE cur,temp;
if(first==NULL)
{
printf("\n the queue is empty");
return first;
}
temp=first;
temp=temp->link;
printf("%d",first->info);
freenode(first);
return temp;
}
void display(NODE first)
{
NODE temp,cur;
int count=0;
if(first==NULL)
{
printf("\n queue is empty");
return first;
}
first=temp;
while(temp!=NULL)
{
printf("\n delete node is %d",temp->info);
temp=temp->link;
count++;
}
printf("\n the total count of the nodes are: %d",count);
printf("\n");
}
8. Design, Develop and Implement a menu driven Program in C for the following operations on
Circular Singly Linked List (CSLL) for data of integers.
● Create a CSLL of data using front insertion.
● Perform Insertion and Deletion to the right of the given node.
● Perform Insertion and Deletion at end of CSLL.
● Display the status of CSLL and count the number of nodes in it.
● Exit
#include < stdio.h>
#include < stdlib.h>
struct node {
int info;
struct node *link;
};
typedef struct node *NODE;
NODE getnode() {
NODE X;
X = (NODE)malloc(sizeof(struct node));
if (X == NULL)
printf("Memory allocation failed\n");
return (X);
}
void freenode(NODE X) {
free(X);
}
NODE insertfront(NODE last, int value) {
NODE temp;
temp = getnode();
temp->info = value;
temp->link = NULL;
if (last == NULL)
last = temp;
else {
temp->link = last->link;
last->link = temp;
}
return (last);
}
NODE insertrear(NODE last, int value) {
NODE temp;
temp = getnode();
temp->info = value;
temp->link = temp;
if (last == NULL)
last = temp;
else {
temp->link = last->link;
last->link = temp;
}
return (temp);
}
NODE deleterear(NODE last) {
NODE prev;
if (last == NULL) {
printf("List is empty\n");
return last;
}
if (last->link == last) {
printf("Deleted item is %d\n", last->info);
freenode(last);
return NULL;
}
else {
prev = last->link;
while (prev->link != last) {
prev = prev->link;
}
prev->link = last->link;
printf("Deleted element is %d\n", last->info);
freenode(last);
return prev;
}
}
void display(NODE last) {
NODE cur;
int count = 0;
if (last == NULL) {
printf("List is empty\n");
return;
}
printf("Contents of CLL are:\n");
cur = last->link;
while (cur != last) {
count++;
printf("%d\n", cur->info);
cur = cur->link;
}
printf("%d\n", cur->info);
count++;
printf("Number of elements are %d\n", count);
}
NODE insertright(NODE last, int key, int value) {
if (last == NULL) {
printf("List is empty\n");
return NULL;
}
NODE cur = last->link; // Start from the first node
NODE temp;
if (last->link == last&&last->info==key) {
temp = getnode();
temp->info = value;
temp->link = last->link; // Link temp to itself
last->link = temp; // Update last's link to temp
return temp; // Return the newly inserted node
}
while (cur != last) {
if (cur->info == key) {
temp = getnode();
temp->info = value;
temp->link = cur->link; // Link temp to the node after cur
cur->link = temp; // Link cur to temp
return last; // Return last as the list hasn't changed
}
cur = cur->link;
}
if (cur->info == key) { // Check the last node separately
temp = getnode();
temp->info = value;
temp->link = last->link; // Link temp to the node after last
last->link = temp; // Link last to temp
return last; // Return last as the list hasn't changed
}
printf("Node with given value %d not found in the list\n", key);
return last; // Return last as the list hasn't changed
}
NODE deleteright(NODE last, int key) {
if (last == NULL || last->link == last) {
printf("List is empty or contains only one node\n");
return last;
}
NODE cur, temp;
cur = last->link;
do {
if (cur->info == key) {
temp = cur->link;
cur->link = temp->link;
printf("Deleted element is %d\n", temp->info);
freenode(temp);
return last;
}
cur = cur->link;
} while (cur != last);
printf("Node with value %d not found in the list\n", key);
return last;
}
int main() {
int choice, value,key,delkey;
NODE pos;
NODE last = NULL;
while (1) {
printf("\nEnter your choice:\n");
printf("1. Insert rear\n2. Delete rear\n3. Insert front\n4. Display\n5. Insert after
\n6.delete right\n7. Exit\n");
scanf("%d", &choice);
switch (choice) {
case 1:
printf("Enter the value you want to insert: ");
scanf("%d", &value);
last = insertrear(last, value);
break;
case 2:
last = deleterear(last);
break;
case 3:
printf("Enter the value you want to insert: ");
scanf("%d", &value);
last = insertfront(last, value);
break;
case 4:
display(last);
break;
case 5:
printf("enter the nodevalue beside which u want to enter the node");
scanf("%d",&key);
printf("enter the value you want to insert");
scanf("%d",&value);
last = insertright(last,key,value);
break;
case 6 :
printf("enter the nodevalue beside which u want to delete the node");
scanf("%d",&delkey);
last = deleteright(last,delkey);
break;
case 7:
exit(0);
default:
printf("Invalid choice\n");
}
}
return 0;
}
9. Design, Develop and Implement a menu driven Program in C for the following operations on
Doubly Linked List (DLL) for data of integers.
● Create a DLL of data .
● Perform Insertion and Deletion at End of DLL.
● Perform Insertion and Deletion at Front of DLL.
● Display the status of DLL and count the number of nodes in it.
● Exit
#include < stdio.h>
#include < stdlib.h>
struct node
{
int info;
struct node *rlink;
struct node *llink;
};
typedef struct node *NODE;
NODE createnode(int value)
{
NODE X;
X = (NODE)malloc(sizeof(struct node));
if(X==NULL)
printf("memo allocation fail");
X->info = value;
X->rlink= X->llink = NULL;
return(X);
}
void freenode(NODE X)
{
free(X);
}
NODE insertrear(NODE first)
{
NODE temp;
int value;
NODE cur;
printf("insert the value you want to insert");
scanf("%d",&value);
temp = createnode(value);
if(first == NULL)
return(temp);
else
{
cur = first;
while(cur->rlink!=NULL)
{
cur = cur -> rlink ;
}
cur -> rlink =temp;
temp->llink =cur;
return (first);
}
}
NODE deleterear (NODE first)
{
NODE cur,prev;
if(first==NULL)
printf("list is empty");
if(first->rlink==NULL)
{
printf("deleted element is %d",first->info);
freenode(first);
return (NULL);
}
else
{
prev = NULL;
cur = first;
while(cur->rlink!=NULL)
{
prev = cur;
cur = cur->rlink;
}
printf("deleted element is %d",cur->info);
freenode(cur);
prev->rlink=NULL;
return(first);
}
}
NODE insertfront(NODE first)
{
int value;
NODE temp;
printf("insert the value you want to insert");
scanf("%d",&value);
temp =createnode(value);
if(first==NULL)
return(temp);
temp->rlink= first;
first->llink=temp;
return (temp);
}
NODE deletefront(NODE first)
{
NODE second;
if(first==NULL) //check for empty list
{
printf("List is empty cannot deleted\n");
return NULL; //we can replace NULL with first also
}
if(first->rlink==NULL) //delete if there is only one node
{
printf("item deleted=%d\n",first->info);
free(first);
return NULL;
}
second=first->rlink; //get the address of second node
second->llink=NULL;//make second node as first node
printf("item deleted=%d\n",first->info);
free(first); //delete the first node
return second;
}
void display( NODE first)
{
int count;
NODE cur;
if(first==NULL)
printf("stack is empty");
if(first->rlink==NULL)
{
printf("%d",first->info);
count++;
printf("number of nodes is %d",count);
}
else
{
printf("contents are : \n");
cur=first;
while(cur!=NULL)
{
count++;
printf("%d \n",cur->info);
cur=cur->rlink;
}
printf("\n");
printf(" number of nodes is %d \n",count);
}
}
int main()
{
int choice,value;
NODE first = NULL;
while(1)
{
printf(" \n enter your choice \n");
printf("1.insertrear \n 2.deleterear \n 3.insertfront \n 4.deletefront \n 5.display \n 6.exit \n");
scanf("%d",&choice);
switch(choice)
{
case 1:
first = insertrear(first);
break;
case 2:
first= deleterear(first); break;
case 3:
first = insertfront(first);
break;
case 4:
first = deletefront(first);
break;
case 5:
display(first);break;
case 6:
exit(0);
}
}
return 0;
}

	    
___________________________________________________________________________________________________________________________________________
_____________________________________________________________________________________________________
______________________________________________________________________________________________________________________
	_____________________________________    __________________________________________________________________________________________
~ 1 ~ DATA STRUCTURES LAB PROGRAMS STACK:

1. Stack using Arrays Write a C program for the
  following operations on a stack of integers (use arrays).a) Push
    b) Pop c) Display
#include<stdio.h>
#include<stdlib.h>
#define SIZE 5
  int top = -1;
void push (int a[], int item)
{
  top = top + 1;
  a[top] = item;
}

int pop (int a[])
{
  int item;
  item = a[top];
  top = top - 1;
  return item;
}

void display (int a[])
{
  int i;
  if (top == -1)
    printf ("The stack is empty\n");
  else if (top != -1)
    {
      printf ("The stack elements are\n");
      for (i = top; i >= 0; i--)
	printf ("%d ", a[i]);
      printf ("\n");
    }
}

int main ()
{
  int s[10], choice, item;
  ~2 ~ while (1)
    {
      printf ("Enter the choice\n");
      printf ("1 Push\n2 Pop\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  if (top == SIZE - 1)
	    {
	      printf ("The stack is full\n");
	      break;
	    }
	  else
	    {
	      printf ("Enter the element to be pushed\n");
	      scanf ("%d", &item);
	      push (s, item);
	    }
	  break;
	case 2:
	  if (top == -1)
	    {
	      printf ("The stack is empty\n");
	      break;
	    }
	  item = pop (s);
	  printf ("Popped element is %d\n", item);
	  break;
	case 3:
	  display (s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

2.Stack - Structure Write a C program for the
  following operations on a stack of integers (use structure).a) Push b) Pop
    c) Display
#include<stdio.h>
#include<stdlib.h>~ 3 ~
#define MAX 10
    struct stack
  {
    int top;
    int items[MAX];
  };

void push (int, struct stack *);
void pop (struct stack *);
void display (struct stack *);
int main ()
{
  struct stack s;
  s.top = -1;
  int choice, item;
  for (;;)
    {
      printf ("Enter your choice\n");
      printf ("1 Push\n2 Pop\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the item\n");
	  scanf ("%d", &item);
	  push (item, &s);
	  break;
	case 2:
	  pop (&s);
	  break;
	case 3:
	  display (&s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

void push (int item, struct stack *s)
{
  if (s->top == MAX - 1)
    printf ("The stack is full\n");
  else
    {
      ~4 ~ (s->top)++;
      s->items[s->top] = item;
    }
}

void pop (struct stack *s)
{
  int item;
  if (s->top == -1)
    printf ("The stack is empty\n");
  else
    {
      item = s->items[s->top];
      (s->top)--;
      printf ("%d deleted\n", item);
    }
}

void display (struct stack *s)
{
  int t = s->top;
  if (s->top == -1)
    printf ("The stack is empty\n");
  else
    {
      printf ("Elements in the stack are\n");
      while (t > -1)
	{
	  printf ("%d ", s->items[t--]);
	}
      printf ("\n");
    }
}

3.String Palindrome using Stack
  Write a C program to check given a string is a palindrome or not using
  stack.
#include<stdio.h>
#include<stdlib.h>
#define max 30
char stack[max], c[max], d[max];
int top = -1, j = 0, k = 0;
char pop ();
~5 ~ void push (char);
int main ()
{
  char a[30], b[30], sym;
  int m = 0, i;
  printf ("Enter a string\n");
  gets (a);
  if (a[0] == '\0')
    printf ("Enter valid string\n");
  else
    {
      for (i = 0; a[i] != '\0'; i++)
	m++;
      for (i = 0; i < m; i++)
	{
	  sym = a[i];
	  push (sym);
	}
      for (i = 0; (i < m) && (top != -1); i++)
	b[i] = pop ();
      b[i] = '\0';
      d[k] = '\0';
      printf ("Reverse of given string is\n");
      printf ("%s\n", d);
      for (i = 0; b[i] != '\0'; i++)
	{
	  if (c[i] != b[i])
	    {
	      printf ("String is not a palindrome\n");
	      exit (0);
	    }
	}
      printf ("String is a palindrome\n");
    }
  return 0;
}

void push (char sym)
{
  if (top == max - 1)
    {
      ~6 ~ printf ("Stack is full\n");
      return;
    }
  top++;
  stack[top] = sym;
  if (sym != ' ')
    c[j++] = sym;
}

char pop ()
{
  if (top == -1)
    {
      printf ("Stack is empty\n");
      exit (0);
    }
  if (stack[top] == 32)
    d[k++] = stack[top--];
  d[k++] = stack[top];
  return (stack[top--]);
}

4.Infix to postfix Write a C program to convert and print a given valid parenthesized infix arithmetic expression to postfix expression.The expression consists of single character operands and +, -, *, /operators.Constraints:only four operators used +, -, *,
  /.
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<ctype.h>
#include<string.h>
#define max 100
#define TRUE 1
#define FALSE 0
  struct stack
{
  int top;
  char items[max];
};

struct stack s;
char infix[max], postfix[max];
~7 ~ int pos = 0;
void convert ();
void push (char);
char pop ();
int precedence (char);
int f = 0;
int empty ();
int stackfull ();
int main ()
{
  s.top = -1;
  printf ("Enter the infix expression\n");
  gets (infix);
  convert ();
  if (f == 0)
    {
      printf ("The postfix expression is\n");
      puts (postfix);
    }
  return 0;
}

void convert ()
{
  if (infix[0] == b \0 b  )
    {
      f = 1;
      printf (b Invalid input \ n b  );
      return;
    }
  int i;
  char symbol, temp;
  for (i = 0; infix[i] != '\0'; i++)
    {
      symbol = infix[i];
      switch (symbol)
	{
	case '(':
	  push (symbol);
	  break;
	case ')':
	  while ((temp = pop ()) != '(')
	    postfix[pos++] = temp;
	  break;
	case '+':
	case '-':
	case '*':
	~8 ~ case '/':
	case '$':
	  while (!empty ()
		 && precedence (s.items[s.top]) >= precedence (symbol)
		 && precedence (symbol) != -1)
	    {
	      temp = pop ();
	      postfix[pos++] = temp;
	    }
	  push (symbol);
	  break;
	default:
	  if (!isalpha (symbol))
	    {
	      printf ("Invalid input\n");
	      f = 1;
	      return;
	    }
	  else
	    {
	      postfix[pos++] = symbol;
	      break;
	    }
	}
    }
  while (!empty ())
    {
      temp = pop ();
      postfix[pos++] = temp;
    }
}

void push (char ele)
{
  if (stackfull ())
    printf ("Stack is full\n");
  else
    s.items[++s.top] = ele;
}

char pop ()
{
  if (empty ())
    {
      ~9 ~ printf ("Stack is empty\n");
      exit (0);
    }
  else
    return (s.items[s.top--]);
}

int stackfull ()
{
  if (s.top == max - 1)
    return TRUE;
  else
    return FALSE;
}

int empty ()
{
  if (s.top == -1)
    return TRUE;
  else
    return FALSE;
}

int precedence (char symbol)
{
  switch (symbol)
    {
    case '$':
      return 3;
    case '*':
    case '/':
      return 2;
    case '+':
    case '-':
      return 1;
    case '(':
    case ')':
      return (0);
    default:
      printf ("Invalid input\n");
      return -1;
    }
}

5.Suffix - Postfix
  Write a C program to evaluate a valid suffix /
  postfix expression using the stack.Assume that suffix /
  postfix expression is read as a single line consisting of non b  negative
  single digit operands and binary arithmetic operators.
  The arithmetic operators are +, -, /, *, ^, ($).
#include<stdio.h>
#include<stdlib.h>~ 10 ~
#include<ctype.h>
#include<math.h>
#include<string.h>
#define size 10
  struct stack
{
  int top;
  double item[size];
};

double op (char, double, double);
void push (char, struct stack *);
double pop (struct stack *);
int main ()
{
  int i;
  double op1, op2, res;
  struct stack s;
  s.top = -1;
  char postfix[20], sym;
  printf ("Enter the postfix expression\n");
  gets (postfix);
  for (i = 0; i < strlen (postfix); i++)
    {
      sym = postfix[i];
      if (isdigit (sym))
	push (sym, &s);
      else
	{
	  op2 = pop (&s);
	  op1 = pop (&s);
	  res = op (sym, op1, op2);
	  if (res == -9999)
	    {
	      printf ("Invalid input");
	      return 0;
	    }
	  s.item[++s.top] = res;
	}
    }
  res = s.item[s.top--];
  ~11 ~ printf ("Result after evaluation is %.2f", res);
  return 0;
}

void push (char sym, struct stack *s)
{
  s->top++;
  s->item[s->top] = sym - '0';
}

double pop (struct stack *s)
{
  double ele;
  ele = s->item[s->top];
  s->top--;
  return (ele);
}

double op (char sym, double op1, double op2)
{
  switch (sym)
    {
    case '+':
      return (op1 + op2);
    case '-':
      return (op1 - op2);
    case '*':
      return (op1 * op2);
    case '/':
      return (op1 / op2);
    case '&':
    case '^':
      return (pow (op1, op2));
    default:
      return -9999;
    }
  exit (0);
}

QUEUE:
6. Queue
  Write a C program to simulate the working of a queue of integers using
  structure.Provide the following operations i)
     Insert ii)
     Delete iii) Display
#include<stdio.h>
#include<stdlib.h>
#define MAX 5
     struct queue
     {
       int rear, front;
       ~12 ~ int q[MAX];
     };

void INSERT (int, struct queue *);
void DELETE (struct queue *);
void DISPLAY (struct queue *);
int main ()
{
  int choice, item;
  struct queue s;
  s.rear = -1;
  s.front = 0;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insertion\n2 Deletion\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  if (s.rear == MAX - 1)
	    printf ("Queue is full\n");
	  else
	    {
	      printf ("Enter the element to be inserted\n");
	      scanf ("%d", &item);
	      INSERT (item, &s);
	    }
	  break;
	case 2:
	  DELETE (&s);
	  break;
	case 3:
	  DISPLAY (&s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

void INSERT (int item, struct queue *s)
{
  s->rear = s->rear + 1;
  s->q[s->rear] = item;
} ~13 ~ void DELETE (struct queue *s)

{
  int item;
  if (s->front > s->rear)
    printf ("Queue is empty\n");
  else
    {
      item = s->q[s->front];
      printf ("%d deleted\n", item);
      (s->front)++;
    }
}

void DISPLAY (struct queue *s)
{
  int i;
  if (s->front > s->rear)
    printf ("Queue is empty\n");
  else
    {
      printf ("Elements in the queue are\n");
      for (i = s->front; i <= s->rear; i++)
	printf ("%d ", s->q[i]);
      printf ("\n");
    }
}

7.Circular Queue
  Write a C program to simulate the working of a circular queue of integers
  using array or structure.Provide the following operations.i)
     Insert ii)
     Delete iii) Display
#include<stdio.h>
#include<stdlib.h>
#define SIZE 3
     int items[SIZE];
     int front = -1, rear = -1;
     int isFull ()
     {
       if ((front == rear + 1) || (front == 0 && rear == SIZE - 1))
	 return 1;
       return 0;
     }

~14 ~ int isEmpty ()
{
  if (front == -1)
    return 1;
  return 0;
}

void insert ()
{
  int element;
  if (isFull ())
    printf ("Queue is full\n");
  else
    {
      printf ("Enter the element\n");
      scanf ("%d", &element);
      if (front == -1)
	front = 0;
      rear = (rear + 1) % SIZE;
      items[rear] = element;
    }
}

void delete ()
{
  int element;
  if (isEmpty ())
    printf ("Queue is empty\n");
  else
    {
      element = items[front];
      if (front == rear)
	{
	  front = -1;
	  rear = -1;
	}
      else
	front = (front + 1) % SIZE;
      printf ("Deleted element %d \n", element);
    }
}

void display ()
{
  int i;
  if (isEmpty ())
    ~15 ~ printf ("Queue is empty\n");
  else
    {
      printf ("Elements in the queue\n");
      for (i = front; i != rear; i = (i + 1) % SIZE)
	printf ("%d ", items[i]);
      printf ("%d \n", items[i]);
    }
}

int main ()
{
  int choice;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insertion\n2 Deletion\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  insert ();
	  break;
	case 2:
	  delete ();
	  break;
	case 3:
	  display ();
	  break;
	case 4:
	  exit (0);
	}
    }
}

8.Priority Queue Write a c program to design a priority queue.Provide the following operations:i)
     Insert ii)
     Delete iii) Display
#include<stdio.h>
#include<stdlib.h>
#define MAX 5
     int q[MAX];
     int front = 0, rear = -1, i, j;
     void insert ()
     {
       ~16 ~ printf ("Enter value\n");
       int ele;
       scanf ("%d", &ele);
       if (rear == MAX - 1)
	 printf ("Queue overflow\n");
       else
	 {
	   j = rear;
	   while ((j >= front) && (ele > q[j]))
	     {
	       q[j + 1] = q[j];
	       j--;
	     }
	   q[j + 1] = ele;
	   rear++;
	 }
     }

void delete ()
{
  int flag = 0;
  if (front > rear)
    printf ("There are no elements to delete\n");
  else
    {
      int ele;
      printf ("Enter value to delete\n");
      scanf ("%d", &ele);
      for (i = front; i <= rear; i++)
	{
	  if (q[i] == ele)
	    {
	      flag = 1;
	      for (j = i; j > front; j--)
		q[j] = q[j - 1];
	      front++;
	      break;
	    }
	}
      ~17 ~ if (flag == 0)
	printf ("%d not found\n", ele);
    }
}

void display ()
{
  if (front > rear)
    printf ("Queue is empty\n");
  else
    {
      for (i = front; i <= rear; i++)
	printf ("%d ", q[i]);
      printf ("\n");
    }
}

int main ()
{
  int ch;
  printf ("1 Insert\n2 Delete\n3 Display\n4 Exit\n");
  for (;;)
    {
      printf ("Enter your choice\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  insert ();
	  break;
	case 2:
	  delete ();
	  break;
	case 3:
	  display ();
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

~18 ~ SINGLY LINKED LIST:
9. Stack using Singly Linked List
  Write C program using dynamic variables and pointers to construct a singly
  Linked list to perform the operations of a stack of integers.(Push, Pop,
								Display).i)
     use Structure to create a node ii)
     make use of user - defined data type typedef.
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE X;
  X = (NODE) malloc (sizeof (struct node));
  return (X);
}

void freenode (NODE X)
{
  free (X);
}

NODE insert_front (NODE first, int item)
{
  NODE temp;
  temp = getnode ();
  temp->info = item;
  temp->link = first;
  return (temp);
}

NODE delete_front (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return first;
    }
  ~19 ~ temp = first;
  temp = temp->link;
  printf ("Deleted data is %d\n", first->info);
  freenode (first);
  return (temp);
}

void display (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  printf ("Contents of the Linked list are\n");
  temp = first;
  while (temp != NULL)
    {
      printf ("%d ", temp->info);
      temp = temp->link;
    }
  printf ("\n");
}

int main ()
{
  int choice, item;
  NODE first = NULL;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert rear\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the item\n");
	  scanf ("%d", &item);
	  first = insert_front (first, item);
	  break;
	case 2:
	  first = delete_front (first);
	  break;
	case 3:
	  display (first);
	  ~20 ~ break;
	case 4:
	  exit (0);
	}
    }
}

10. Queue using Singly Linked List
  Write a C program using dynamic variables and pointers to construct a singly
  Linked list to perform the operations of a queue of integers.
#include<stdio.h>
#include<stdlib.h>
  struct node
{
  int info;
  struct node *link;
};

typedef struct node *NODE;
NODE getnode ()
{
  NODE X;
  X = (NODE) malloc (sizeof (struct node));
  if (X == NULL)
    {
      printf ("Memeory not available\n");
    }
  return (X);
}

void freenode (NODE X)
{
  free (X);
}

NODE insert_rear (int item, NODE first)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  temp->link = NULL;
  if (first == NULL)
    return (temp);
  cur = first;
  ~21 ~ while (cur->link != NULL)
    {
      cur = cur->link;
    }
  cur->link = temp;
  return (first);
}

NODE delete_front (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return (first);
    }
  temp = first;
  temp = temp->link;
  printf ("Deleted data is %d\n", first->info);
  freenode (first);
  return (temp);
}

void display (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  printf ("Contents of the Linked list are\n");
  temp = first;
  while (temp != NULL)
    {
      printf ("%d ", temp->info);
      temp = temp->link;
    }
  printf ("\n");
}

~22 ~ int main ()
{
  int choice, item;
  NODE first = NULL;
  for (;;)
    {
      printf ("Enter your choice");
      printf ("\n1 Insert rear\n2 Delete front\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &item);
	  first = insert_rear (item, first);
	  break;
	case 2:
	  first = delete_front (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

11. Singly Linked List - Dynamic
  Write a C program using dynamic variables and pointers to construct a singly
  linked list consisting of the following information in each node:student
  id (integer), student name (character string)
     and semester (integer).The operations to be supported are:i)
     Insert at specified position ii)
     Delete front iii) Display
#include<stdio.h>
#include<stdlib.h>
     int count = 0;
     struct node
     {
       int student_id;
       int semester;
       char student_name[20];
       struct node *link;
     ~23 ~};

void insert (struct node **s, int pos)
{
  int i;
  if (pos > count + 1)
    {
      printf ("Invalid position\n");
      return;
    }
  struct node *newnode;
  newnode = (struct node *) malloc (sizeof (struct node));
  printf ("Enter id\n");
  scanf ("%d", &(newnode->student_id));
  printf ("Enter name\n");
  scanf ("%s", newnode->student_name);
  printf ("Enter semester\n");
  scanf ("%d", &(newnode->semester));
  struct node *temp = *s;
  if ((*s) == NULL)
    {
      (*s) = newnode;
      count++;
    }
  e lse if (pos == 0 || pos == 1)
    {
      count++;
      newnode->link = *s;
      *s = newnode;
    }
  else
    {
      for (i = 2; i < pos; i++)
	{
	  temp = temp->link;
	}
      newnode->link = temp->link;
      temp->link = newnode;
      count++;
    }
}

~24 ~ void delete_front (struct node **s)
{
  if ((*s) == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  struct node *temp = *s;
  struct node *cur = temp->link;
  *s = cur;
  int item = temp->student_id;
  free (temp);
  printf ("Deleted ID is %d\n", item);
}

void display (struct node *s)
{
  if (s == NULL)
    {
      printf ("List is empty\n");
      return;
    }
  struct node *temp = s;
  printf ("Contents are\n");
  while (temp != NULL)
    {
      printf ("ID %d\n", temp->student_id);
      printf ("Name %s\n", temp->student_name);
      printf ("Semester %d\n", temp->semester);
      temp = temp->link;
    }
}

int main ()
{
  int choice, pos;
  struct node *s = NULL;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert at position\n2 Delete front\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      ~25 ~ switch (choice)
	{
	case 1:
	  printf ("Enter the position\n");
	  scanf ("%d", &pos);
	  insert (&s, pos);
	  break;
	case 2:
	  delete_front (&s);
	  break;
	case 3:
	  display (s);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

12. Circular Linked List
  Write a C program to support the following operations on a circular linked
  list where each node consists of integers.1. Insert rear 2. Delete rear 3.
  Display.
#include<stdio.h>
#include<stdlib.h>
  struct node
{
  int data;
  struct node *link;
};

typedef struct node *NODE;
NODE insert_rear (NODE first, int item)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->data = item;
  if (first == NULL)
    {
      first = newnode;
      first->link = newnode;
      ~26 ~ return first;
    }
  else
    {
      NODE temp = first;
      while (temp->link != first)
	temp = temp->link;
      temp->link = newnode;
      newnode->link = first;
      return first;
    }
}

NODE delete_rear (NODE first)
{
  if (first == NULL)
    {
      printf ("List is empty\n");
      return first;
    }
  else
    {
      int itm;
      NODE temp = first;
      if (first->link == first)
	{
	  itm = first->data;
	  free (temp);
	  first = NULL;
	}
      else
	{
	  NODE prev = NULL;
	  while (temp->link != first)
	    {
	      prev = temp;
	      temp = temp->link;
	    }
	  prev->link = first;
	  itm = temp->data;
	  ~27 ~ free (temp);
	}
      printf ("Deleted data is %d\n", itm);
      return first;
    }
}

void display (NODE first)
{
  if (first == NULL)
    {
      printf ("List is empty");
      return;
    }
  else
    {
      NODE temp;
      temp = first;
      printf ("Contents of the Circular Linked list are\n");
      while (temp->link != first)
	{
	  printf ("%d ", temp->data);
	  temp = temp->link;
	}
      printf ("%d", temp->data);
    }
}

int main ()
{
  int choice, val;
  NODE first = NULL;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert rear\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  first = insert_rear (first, val);
	  ~28 ~ break;
	case 2:
	  first = delete_rear (first);
	  break;
	case 3:
	  display (first);
	  printf ("\n");
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

DOUBLY LINKED LIST:13. Doubly linked list
  Write a C program to support the following operations on a doubly linked
  list where each node consists of integers.i)
     Insert front ii)
     Delete rear iii) Display.
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE insert_front (NODE first, int val)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->info = val;
  newnode->llink = NULL;
  if (first == NULL)
    {
      first = newnode;
      newnode->rlink = NULL;
      return first;
    }
  else
    {
      newnode->rlink = first;
      ~29 ~ first->llink = newnode;
      return newnode;
    }
}

NODE delete_rear (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return first;
    }
  int del;
  NODE cur = first;
  if (first->rlink == NULL)
    {
      del = first->info;
      free (first);
      first = NULL;
    }
  else
    {
      NODE prev = NULL;
      while (cur->rlink != NULL)
	{
	  cur = cur->rlink;
	}
      prev = cur->llink;
      prev->rlink = NULL;
      del = cur->info;
      free (cur);
    }
  printf ("Deleted data is %d\n", del);
  return first;
}

void display (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return;
    }
  ~30 ~
  else
    {
      NODE temp = first;
      while (temp != NULL)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
      printf ("\n");
    }
}

int main ()
{
  NODE first = NULL;
  int choice, val;
  while (1)
    {
      printf
	("Enter your choice\n1 Insert front\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  first = insert_front (first, val);
	  break;
	case 2:
	  first = delete_rear (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

14. Circular Doubly Linked List I
  Write a C program to support the following operations on a circular doubly
  linked list (with or without header node where each node consists of
	       integers.i)
     Insert front ii)
     Delete rear iii) Display. ~ 31 ~
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE insert_front (NODE first, int val)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->info = val;
  if (first == NULL)
    {
      first = newnode;
      newnode->llink = newnode;
      newnode->rlink = newnode;
      return first;
    }
  else
    {
      NODE last = first->llink;
      newnode->rlink = first;
      newnode->llink = last;
      last->rlink = newnode;
      first->llink = newnode;
      return newnode;
    }
}

NODE delete_rear (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return first;
    }
  int del;
  NODE cur = first;
  ~32 ~ if (first->rlink == first)
    {
      del = first->info;
      free (first);
      first = NULL;
    }
  else
    {
      NODE prev = NULL;
      cur = first->llink;
      prev = cur->llink;
      prev->rlink = first;
      first->llink = prev;
      del = cur->info;
      free (cur);
    }
  printf ("Deleted data is %d\n", del);
  return first;
}

void display (NODE first)
{
  if (first == NULL)
    {
      printf ("List is Empty\n");
      return;
    }
  else
    {
      NODE temp = first;
      while (temp->rlink != first)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
      printf ("%d \n", temp->info);
    }
}

int main ()
{
  NODE first = NULL;
  int choice, val;
  ~33 ~ while (1)
    {
      printf
	("Enter your choice\n1 Insert front\n2 Delete rear\n3 Display\n4 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  first = insert_front (first, val);
	  break;
	case 2:
	  first = delete_rear (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

15. Circular doubly linked list II
  Write a C program to support the following operations on a circular doubly
  linked list (with or without header node)
     where each node consists of integers.i)
     Insert rear ii)
     Delete front iii)
     Insert Right iv) Display
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int info;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE insert_rear (NODE head, int val)
{
  NODE newnode;
  newnode = (NODE) malloc (sizeof (struct node));
  newnode->info = val;
  if (head->rlink == head)
    ~34 ~
    {
      head->rlink = newnode;
      head->llink = newnode;
      newnode->llink = head;
      newnode->rlink = head;
      return head;
    }
  else
    {
      NODE temp = head->llink;
      temp->rlink = newnode;
      newnode->llink = temp;
      newnode->rlink = head;
      head->llink = newnode;
      return head;
    }
}

NODE delete_front (NODE head)
{
  int del;
  NODE temp = head->rlink;
  if (head->rlink == head)
    {
      printf ("List is empty\n");
      return head;
    }
  else
    {
      NODE next = temp->rlink;
      head->rlink = next;
      next->llink = head;
      del = temp->info;
      free (temp);
      printf ("%d deleted\n", del);
      return head;
    }
}

void display (NODE head)
{
  if (head->rlink == head)
    ~35 ~
    {
      printf ("List is empty\n");
      return;
    }
  else
    {
      printf ("Contents of the Circular Doubly Linked list are\n");
      NODE temp = head->rlink;
      while (temp != head)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
      printf ("\n");
    }
}

NODE insert_right (NODE head, int key, int val)
{
  NODE temp = head->rlink;
  while (temp != head)
    {
      if (temp->info == key)
	break;
      temp = temp->rlink;
    }
  if (temp == head)
    {
      printf ("Key not found\n");
      return head;
    }
  else
    {
      NODE newnode;
      newnode = (NODE) malloc (sizeof (struct node));
      newnode->info = val;
      NODE next = temp->rlink;
      temp->rlink = newnode;
      newnode->llink = temp;
      newnode->rlink = next;
      next->llink = newnode;
      ~36 ~ return head;
    }
}

int main ()
{
  NODE head = (NODE) malloc (sizeof (struct node));
  head->info = 0;
  head->rlink = head;
  head->llink = head;
  int choice, val, key;
  for (;;)
    {
      printf
	("Enter your choice\n1 Insert rear\n2 Delete front\n3 Insert right\n4 Display\n5 Exit\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the data\n");
	  scanf ("%d", &val);
	  head = insert_rear (head, val);
	  break;
	case 2:
	  head = delete_front (head);
	  break;
	case 3:
	  printf ("Enter the key\n");
	  scanf ("%d", &key);
	  printf ("Enter a node\n");
	  scanf ("%d", &val);
	  head = insert_right (head, key, val);
	  break;
	case 4:
	  display (head);
	  break;
	case 5:
	  exit (0);
	  break;
	default:
	  printf ("Invalid input\n");
	}
    }
  return 0;
}

~37 ~ TREES:
16. Binary Tree
  Write a C program to implement a binary tree of integers and perform the
  following traversal techniques.i) In - order traversal ii) Post -
  order traversal iii) Pre - order traversal.
#include<stdio.h>
#include<stdlib.h>
  struct node
{
  int info;
  struct node *lchild;
  struct node *rchild;
};

typedef struct node *NODE;
NODE create_B_Tree ()
{
  NODE newnode;
  int data = 0;
  newnode = NULL;
  printf ("Enter data ('0' if no data)");
  scanf ("%d", &data);
  if (data)
    {
      newnode = (NODE) malloc (sizeof (struct node));
      newnode->info = data;
      printf ("\nLeft child of %d\n", newnode->info);
      newnode->lchild = create_B_Tree ();
      printf ("\nRight child of %d\n", newnode->info);
      newnode->rchild = create_B_Tree ();
    }
  return newnode;
}

void pre_order (NODE root)
{
  if (root != NULL)
    {
      printf ("%d\n", root->info);
      pre_order (root->lchild);
      pre_order (root->rchild);
    ~38 ~}
}

void post_order (NODE root)
{
  if (root != NULL)
    {
      post_order (root->lchild);
      post_order (root->rchild);
      printf ("%d\n", root->info);
    }
}

void in_order (NODE root)
{
  if (root != NULL)
    {
      in_order (root->lchild);
      printf ("%d\n", root->info);
      in_order (root->rchild);
    }
}

int main ()
{
  printf ("Create binary tree, start from root\n");
  NODE root;
  root = create_B_Tree ();
  while (1)
    {
      printf ("Select mode of traversal for displaying the binary tree\n");
      printf ("1 Pre-order\n2 Post-order\n3 In-order\n4 Exit\nChoice \n");
      int choice;
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  pre_order (root);
	  printf ("\n");
	  break;
	case 2:
	  post_order (root);
	  printf ("\n");
	  break;
	case 3:
	  in_order (root);
	  ~39 ~ printf ("\n");
	  break;
	case 4:
	  exit (0);
	}
    }
  return 0;
}

17.Ex pression Tree
  Write a C program to construct expression tree for the given postfix
  expression and evaluate the same.
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#define max 100
  struct node
{
  int data;
  struct node *llink, *rlink;
};

typedef struct node *NODE;
NODE construct_tree (char postfix[max])
  {
    if (postfix[0] == b \0 b  )
      return NULL;
    char sym;
    NODE newnode, stack[max];
    int i, top = -1;
    for (i = 0; postfix[i] != '\0'; i++)
      {
	sym = postfix[i];
	newnode = (NODE) malloc (sizeof (struct node));
	newnode->data = sym;
	newnode->llink = NULL;
	newnode->rlink = NULL;
	if (isdigit (sym))
	  {
	    stack[++top] = newnode;
	    continue;
	  }
	switch (sym)
	  {
	  ~40 ~ case '+':
	  case '-':
	  case '*':
	  case '/':
	    newnode->rlink = stack[top--];
	    newnode->llink = stack[top--];
	    stack[++top] = newnode;
	    break;
	  default:
	    return NULL;
	  }
      }
    return stack[top--];
  }

float evaluate (NODE root)
{
  switch (root->data)
    {
    case '+':
      return (evaluate (root->llink) + evaluate (root->rlink));
    case '-':
      return (evaluate (root->llink) - evaluate (root->rlink));
    case '*':
      return (evaluate (root->llink) * evaluate (root->rlink));
    case '/':
      return (evaluate (root->llink) / evaluate (root->rlink));
    default:
      return (root->data - '0');
    }
}

int main ()
{
  float res;
  char postfix[max];
  NODE root = NULL;
  printf ("Enter the postfix expression\n");
  gets (postfix);
  root = construct_tree (postfix);
  if (root == NULL)
    {
      printf ("Invalid input\n");
      return 0;
    }
  res = evaluate (root);
  printf ("Result after evaluation is %.2f\n", res);
  return 0;
}

~41 ~ 18. Binary - Search Tree Write a C program to implement a binary search tree of integers and perform the following traversal techniques:
i) In - order traversal
  ii)
     Find the maximum element iii)
     Search an element
       Display "Duplication is not allowed" if same element is inserted
       again.Display "Key element not found" if searched element is not
       present in the tree.Display "Search is successful" if searched element
       is present in the tree.Displpay "Maximum element is 15" if the maximum
       element is 15 in the tree.
#include<stdio.h>
#include<stdlib.h>
     struct node
     {
       int data;
       struct node *llink, *rlink;
     };

typedef struct node *NODE;
NODE create_node (int val)
  {
    NODE newnode;
    newnode = (NODE) malloc (sizeof (struct node));
    newnode->data = val;
    newnode->llink = NULL;
    newnode->rlink = NULL;
    return newnode;
  }
void setleft (NODE p, int val)
{
  if (p == NULL)
    printf ("Insertion is not possible\n");
  else if (p->llink != NULL)
    printf ("Invalid insertion\n");
  else
    p->llink = create_node (val);
}

void setright (NODE p, int val)
{
  if (p == NULL)
    printf ("Insertion is not possible\n");
  else if (p->rlink != NULL)
    ~42 ~ printf ("Invalid insertion\n");
  else
    p->rlink = create_node (val);
}

NODE create_BS_Tree (NODE root, int val)
{
  if (root == NULL)
    {
      root = create_node (val);
    }
  else
    {
      NODE p, q;
      p = q = root;
      while (val != p->data && q != NULL)
	{
	  p = q;
	  if (val < p->data)
	    q = p->llink;
	  else
	    q = p->rlink;
	}
      if (val == p->data)
	{
	  printf ("Duplication is not allowed\n");
	}
      else if (val < p->data)
	setleft (p, val);
      else
	setright (p, val);
    }
  return root;
}

void inorder (NODE root)
{
  if (root != NULL)
    {
      inorder (root->llink);
      printf ("%d ", root->data);
      ~43 ~ inorder (root->rlink);
    }
}

void search (NODE root, int key)
{
  NODE p, q;
  p = q = root;
  while (key != p->data && q != NULL)
    {
      p = q;
      if (key < p->data)
	q = p->llink;
      else
	q = p->rlink;
    }
  if (key == p->data)
    printf ("Search is successful\n");
  else
    printf ("Key element not found\n");
}

int maximum (NODE root)
{
  while (root->rlink != NULL)
    {
      root = root->rlink;
    }
  return root->data;
}

int main ()
{
  int choice, val, key, max;
  NODE root = NULL;
  printf ("1 Insert\n2 In-order\n3 Search\n4 Maximum\n5 Exit\n");
  while (1)
    {
      printf ("Enter your Choice\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	~44 ~ case 1:
	  printf ("Enter the element\n");
	  scanf ("%d", &val);
	  root = create_BS_Tree (root, val);
	  break;
	case 2:
	  inorder (root);
	  printf ("\n");
	  break;
	case 3:
	  printf ("Enter the element to be searched\n");
	  scanf ("%d", &key);
	  search (root, key);
	  break;
	case 4:
	  max = maximum (root);
	  printf ("Maximum element is %d\n", max);
	  break;
	case 5:
	  exit (0);
	  break;
	default:
	  printf ("Invalid choice\n");
	}
    }
  return 0;
  ***


















_______________________________________________________________________________________________________________

DS LAB PROGRAMS:01)
     Implement stack operations such as Push,
       Pop and Display using arrays /
       global variables.
       The program should print appropriate messages for stack overflow and
       stack underflow
#include <stdio.h>
#include <stdlib.h>
#define MAX 3
     int top = -1
       , stack[MAX];
     void push ();
     void pop ();
     void display ();
     void main ()
     {
       int ch;
       while (1)
	 {
	   printf ("\n***Stack Menu***");
	   printf ("\n\n1.Push\n2.Pop\n3.Display\n4.Exit");
	   printf ("\n\nEnter your choice(1-4): ");
	   scanf ("%d", &ch);
	   switch (ch)
	     {
	     case 1:
	       push ();
	       break;
	     case 2:
	       pop ();
	       break;
	     case 3:
	       display ();
	       break;
	     case 4:
	       exit (0);
	     default:
	       printf ("\nWrong CHoice!!");
	     }
	 }
     }

void push ()
{
  int val;
  if (top == MAX - 1)
    {
      printf ("\nStack is full!!");
    }
  else
    {
      printf ("\nEnter element to push:");
      scanf ("%d", &val);
      top = top + 1;
      stack[top] = val;
    }
}

void pop ()
{
  if (top == -1)
    {
      printf ("\nStack is empty");
    }
  else
    {
      printf ("\nDeleted element is %d", stack[top]);
      top = top - 1;
    }
}

void display ()
{
  int i;
  if (top == -1)
    {
      printf ("STACK IS EMPTY\n");
    }
  else
    {
      printf ("\nStack is ....\n");
      for (i = top; i >= 0; --i)
	printf ("%d\n", stack[i]);
    }
}

02)
     Convert a given valid parenthesized infix arithmetic expression to
       postfix expression.
       The expression consists of single character operands and +, -, *,
       /operators.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
     int F (char symbol)
     {
       switch (symbol)
	 {
	 case '+':
	 case '-':
	   return 2;
	 case '*':
	 case '/':
	   return 4;
	 case '^':
	 case '$':
	   return 5;
	 case '(':
	   return 0;
	 case '#':
	   return -1;
	 default:
	   return 8;
	 }
     }

int G (char symbol)
{
  switch (symbol)
    {
    case '+':
    case '-':
      return 1;
    case '*':
    case '/':
      return 3;
    case '^':
    case '$':
      return 6;
    case '(':
      return 9;
    case ')':
      return 0;
    default:
      return 7;
    }
}

void infix_postfix (char infix[], char postfix[])
{
  int top;
  int j;
  int i;
  char s[30];
  char symbol;
  top = -1;
  s[++top] = '#';
  j = 0;
  for (i = 0; i < strlen (infix); i++)
    {
      symbol = infix[i];
      while (F (s[top]) > G (symbol))
	{
	  postfix[j] = s[top--];
	  j++;
	}
      if (F (s[top]) != G (symbol))
	s[++top] = symbol;
      else
	top--;
    }
  while (s[top] != '#')
    {
      postfix[j++] = s[top--];
    }
  postfix[j] = '\0';
}

int main ()
{
  char infix[20], postfix[20];
  printf ("ENTER AN INFIX EXPRESSION\n");
  scanf ("%s", infix);
  infix_postfix (infix, postfix);
  printf ("POSTFIX EXPRESSION IS %s", postfix);
  return 0;
}

03)
     Evaluate a valid suffix /
       postfix expression using stack.Assume that suffix /
       postfix expression is read as a single line consisting of non negative
       single digit operands and binary arithmetic operators.
       The arithmetic operators are +, -, /, *, ^($).
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
     double compute (char symbol, double op1, double op2)
     {
       switch (symbol)
	 {
	 case '+':
	   return op1 + op2;
	 case '-':
	   return op1 - op2;
	 case '/':
	   return op1 / op2;
	 case '*':
	   return op1 * op2;
	 case '^':
	 case '$':
	   return pow (op1, op2);
	 default:
	   printf ("invalid operation\n");
	   exit (0);
	 }
     }

int main ()
{
  double s[20], op1, op2, res;
  int top, i;
  char postfix[20], symbol;
  printf ("enter the postfix expression\n");
  scanf ("%s", postfix);
  top = -1;
  for (i = 0; i < strlen (postfix); i++)
    {
      symbol = postfix[i];
      if (isdigit (symbol))
	s[++top] = symbol - '0';
      else
	{
	  op2 = s[top--];
	  op1 = s[top--];
	  res = compute (symbol, op1, op2);
	  s[++top] = res;
	}
    }
  res = s[top--];
  printf ("the result is=%f\n", res);
  return 0;
}

04)
     Find if a given string is a palindrome or not using stack.
#include <stdio.h>
#include <stdlib.h>
#define MAX 50
     int i, top = -1
       , f = 0;
     char s[MAX];
     char a[MAX];
     void push (char);
     char pop ();
     int main ()
     {
       printf ("enter the expression\n");
       scanf ("%s", a);
       for (i = 0; a[i] != '\0'; i++)
	 {
	   push (a[i]);
	 }
       for (i = 0; a[i] != '\0'; i++)
	 {
	   if (a[i] != pop ())
	     {
	       f = 1;
	       break;
	     }
	 }
       if (f == 0)
	 {
	   printf ("it is a palindrome\n");
	 }
       else
	 {
	   printf ("it is not a palindrome\n");
	 }
     }

void push (char ch)
{
  top++;
  s[top] = ch;
}

char pop ()
{
  char x = s[top];
  top--;
  return x;
}

05)
     Implement Queue operations such as Insert, Delete and Display.Display
       appropriate messages on Queue overflow and Queue underflow conditions.
#include <stdio.h>
#include <stdlib.h>
#define que_size 4
     int rear, front, item, q[10];
     void insertq ()
     {
       if (rear == que_size - 1)
	 printf ("Queue Overflow\n");
       else
	 {
	   rear = rear + 1;
	   q[rear] = item;
	 }
     }

int delq ()
{
  if (front > rear)
    return -1;
  else
    return (q[front++]);
}

void display ()
{
  int i;
  if (front > rear)
    printf ("Queue Underflow\n");
  else
    {
      for (i = front; i <= rear; i++)
	{
	  printf ("%d\t\n", q[i]);
	}
    }
}

int main ()
{
  int ch, delitem;
  front = 0;
  rear = -1;
  while (1)
    {
      printf ("1.Insert 2.Delete 3.Display 4.Exit\n");
      printf ("Enter your Choice\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("Enter the Item\n");
	  scanf ("%d", &item);
	  insertq ();
	  break;
	case 2:
	  delitem = delq ();
	  if (delitem == -1)
	    printf ("Queue Underflow\n");
	  else
	    printf ("Deleted item= %d\n", delitem);
	  break;
	case 3:
	  display ();
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("Invalid choice!!try again\n");
	  break;
	}
    }
  return 0;
}

06)
     Implement Circular queue operations such as Insert,
       Delete and Display.
       Display appropriate messages on Queue overflow and Queue underflow
       conditions.
#include <stdio.h>
#include <stdlib.h>
#define que_size 5
     int rear, front, count, item, q[10];
     void insertq ()
     {
       if (count == que_size)
	 {
	   printf ("Queue is full\n");
	   return;
	 }
       rear = (rear + 1) % que_size;
       q[rear] = item;
       count++;
     }

int deleteq ()
{
  if (count == 0)
    return -1;
  item = q[front];
  front = (front + 1) % que_size;
  count -= 1;
  return item;
}

void displayq ()
{
  int i, f;
  if (count == 0)
    {
      printf ("queue is empty\n");
      return;
    }
  else
    for (i = 1, f = front; i <= count; i++)
      {
	printf ("%d\n", q[f]);
	f = (f + 1) % que_size;
      }
}

int main ()
{
  int ch, delitem;
  front = 0;
  rear = -1;
  while (1)
    {
      printf ("1.INSERT 2.DELETE 3.DISPLAY 4.EXIT\n");
      printf ("ENTER YOUR CHOICE\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("Enter the Item:");
	  scanf ("%d", &item);
	  insertq ();
	  break;
	case 2:
	  delitem = deleteq ();
	  if (delitem == -1)
	    printf ("Queue Underflow");
	  else
	    printf ("Deleted Item is %d\n", delitem);
	  break;
	case 3:
	  displayq ();
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("Invalid Choice");
	  break;
	}
    }
  return 0;
}

07)
     Implement Priority queue operations such as Insert, Delete and
       Display.Display appropriate messages on Queue overflow and
       Queue underflow conditions.
#include <stdio.h>
#include <stdlib.h>
#define qsize 3
     void insert (int item, int q[], int *r)
     {
       int j;
       if (*r == qsize - 1)
	 {
	   printf ("QUEUE OVERFLOW\n");
	   return;
	 }
       j = *r;
       while (j >= 0 && item < q[j])
	 {
	   q[j + 1] = q[j];
	   j--;
	 }
       q[j + 1] = item;
       *r = *r + 1;
     }

void display (int *r, int *f, int q[])
{
  int i;
  if (*f > *r)
    printf ("QUEUE IS EMPTY\n");
  else
    {
      for (i = *f; i <= *r; i++)
	printf ("%d ", q[i]);
    }
  printf ("\n");
}

int delete (int *f, int *r, int q[])
{
  if (*f > *r)
    return -1;
  else
    return (q[(*f)++]);
}

int main ()
{
  int front, rear, ch, delitm, item, q[5];
  front = 0;
  rear = -1;
  while (1)
    {
      printf ("ENTER YOUR CHOICE\n");
      printf ("1.INSERT 2.DELETE 3.DISPLAY 4.EXIT\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  insert (item, q, &rear);
	  break;
	case 2:
	  delitm = delete (&front, &rear, q);
	  if (delitm == -1)
	    printf ("QUEUE UNDERFLOW\n");
	  else
	    printf ("DELETED ITEM =%d\n", delitm);
	  break;
	case 3:
	  display (&rear, &front, q);
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("INVALID CHOICE !!TRY AGAIN \n");
	  break;
	}
    }
  return 0;
}

08)
     Implement Insert, Delete and Display operations on Singly Linked List.
#include <stdio.h>
#include <stdlib.h>
#include<ctype.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMEORY \n");
      exit (0);
    }
  return x;
}

NODE insertfront (int item, NODE first)
{
  NODE temp;
  temp = getnode ();
  temp->info = item;
  temp->link = first;
  return temp;
}

void display (NODE first)
{
  NODE temp;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return;
    }
  printf ("THE CONTENTS ARE\n");
  temp = first;
  while (temp != NULL)
    {
      printf ("%d\t", temp->info);
      temp = temp->link;
    }
  printf ("\n");
}

NODE delfront (NODE first)	//FUNCTION TO DELETE FIRST NODE
{
  NODE temp;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return first;
    }
  temp = first;
  first = first->link;
  printf ("DELETED ITEM =%d\n", temp->info);
  free (temp);
  return first;
}

NODE insertrear (int item, NODE first)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  temp->link = NULL;
  if (first == NULL)
    {
      return temp;
    }
  cur = first;
  while (cur->link != NULL)
    {
      cur = cur->link;
    }
  cur->link = temp;
  return first;
}

NODE delrear (NODE first)
{
  NODE cur, prev;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return first;
    }
  if (first->link == NULL)
    {
      printf ("DELETED ITEM IS %d\n", first->info);
      free (first);
      first = NULL;
      return first;
    }
  prev = NULL;
  cur = first;
  while (cur->link != NULL)
    {
      prev = cur;
      cur = cur->link;
    }
  printf ("DELETED ITEM %d\n", cur->info);
  free (cur);
  prev->link = NULL;
  return first;
}

NODE insertpos (int item, int pos, NODE first)
{
  NODE temp, prev, cur;
  int counter;
  temp = getnode ();
  temp->info = item;
  temp->link = NULL;
  if (first == NULL && pos == 1)
    return temp;
  if (first == NULL)
    {
      printf ("INVALID POSITION\n");
      return first;
    }
  if (pos == 1)
    {
      temp->link = first;
      return temp;
    }
  counter = 1;
  prev = NULL;
  cur = first;
  while (cur != NULL && counter != pos)
    {
      prev = cur;
      cur = cur->link;
      counter++;
    }
  if (counter == pos)
    {
      prev->link = temp;
      temp->link = cur;
      return first;
    }
  else
    printf ("INVALID POSITION\n");
  return first;
}

NODE delinfo (int item, NODE first)
{
  NODE prev, cur;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return NULL;
    }
  if (item == first->info)
    {
      cur = first;
      first = first->link;
      free (cur);
      return first;
    }
  prev = NULL;
  cur = first;
  while (cur != NULL && item != cur->info)
    {
      prev = cur;
      cur = cur->link;
    }
  if (cur == NULL)
    {
      printf ("ITEM NOT FOUND\n");
      return first;
    }
  prev->link = cur->link;
  free (cur);
  return first;
}

NODE delpos (int pos, NODE first)
{
  NODE cur, prev;
  int counter;
  if (first == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return NULL;
    }
  if (pos == 1)
    {
      cur = first;
      first = first->link;
      free (cur);
      return first;
    }
  prev = NULL;
  cur = first;
  counter = 1;
  while (cur != NULL && counter != pos)
    {
      prev = cur;
      cur = cur->link;
      counter++;
    }
  if (cur == NULL)
    {
      printf ("INVALID POSITION\n");
      return first;
    }
  else
    prev->link = cur->link;
  free (cur);
  return first;
}

void search (int item, NODE first)
{
  NODE cur;
  int pos;
  if (first == NULL)
    {
      printf ("LIST EMPTY\n");
      return;
    }
  cur = first;
  pos = 1;
  while (cur != NULL && item != cur->info)
    {
      cur = cur->link;
      pos++;
    }
  if (cur == NULL)
    {
      printf ("SEARCH UNSUCCESSFUL");
      return;
    }
  printf ("SEARCH SUCCESSFUL &ITEM FOUND AT %d\n", pos - 1);
}

int main ()
{
  NODE first = NULL;
  int ch, item, pos;
  pos = 0;
  while (1)
    {
      printf ("ENTER YOUR CHOICE\n");
      printf ("1.INSERT AT FRONT END\n2.INSERT AT REAR END\n3.DELETE
AT FRONT END\n");
      printf ("4.DELETE AT REAR END\n5.INSERT AT SPECIFIED POSITION\
n");
      printf ("6.DELETE A PARTICULAR ELEMENT\n");
      printf ("7.DELETE AT SPECIFIED POSITION\n");
      printf ("8.SEARCH FOR A PARTICULAR ELEMENT\n");
      printf ("9.DISPLAYING THE LINKED LIST\n");
      printf ("10.EXIT\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ELEMENT\n");
	  scanf ("%d", &item);
	  first = insertfront (item, first);
	  break;
	case 2:
	  printf ("ENTER THE ELEMENT\n");
	  scanf ("%d", &item);
	  first = insertrear (item, first);
	  break;
	case 3:
	  first = delfront (first);
	  break;
	case 4:
	  first = delrear (first);
	  break;
	case 5:
	  printf ("ENTER THE ITEM TO BE INSERTED\n");
	  scanf ("%d", &item);
	  printf ("ENTER THE POSITION OF INSERTION\n");
	  scanf ("%d", &pos);
	  first = insertpos (item, pos, first);
	  break;
	case 6:
	  printf ("ENTER THE ELEMENT TO BE DELETED\n");
	  scanf ("%d", &item);
	  first = delinfo (item, first);
	  break;
	case 7:
	  printf ("ENTER THE POSITION OF DELETION\n");
	  scanf ("%d", &pos);
	  first = delpos (pos, first);
	  break;
	case 8:
	  printf ("ENTER THE SEARCH ELEMENT\n");
	  scanf ("%d", &item);
	  search (item, first);
	  break;
	case 9:
	  display (first);
	  break;
	case 10:
	  exit (0);
	default:
	  printf ("WRONG CHOICE!!TRY AGAIN\n");
	}
    }
  return 0;
}


09)
     Implement stack / queue operations using linked list.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("\nOUT OF MEMORY");
      exit (0);
    }
  return x;
}

NODE insert_front (int item, NODE first)
{
  NODE temp;
  temp = getnode ();
  temp->info = item;
  temp->link = first;
  return temp;
}

void display (NODE first)
{
  NODE cur;
  if (first == NULL)
    {
      printf ("\nLIST IS EMPTY");
      return;
    }
  printf ("\nThe contents of list are:\n");
  cur = first;
  while (cur != NULL)
    {
      printf ("%d\n", cur->info);
      cur = cur->link;
    }
  printf ("\n");
}

NODE delete_front (NODE first)
{
  NODE cur;
  if (first == NULL)
    {
      printf ("\nLIST IS EMPTY");
      return first;
    }
  cur = first;
  cur = cur->link;
  printf ("\nDELETED ITEM:%d", first->info);
  free (first);
  return cur;
}

int main ()
{
  NODE first;
  first = NULL;
  int op, item;
  while (1)
    {
      printf ("\n1.INSERT AT THE FRONT END \n2.DELETE AT THE FRONT
END");
      printf ("\n3.DISPLAY \n4.EXIT");
      printf ("\nENTER YOUR OPTION:");
      scanf ("%d", &op);
      switch (op)
	{
	case 1:
	  printf ("Enter the item to be inserted:");
	  scanf ("%d", &item);
	  first = insert_front (item, first);
	  break;
	case 2:
	  first = delete_front (first);
	  break;
	case 3:
	  display (first);
	  break;
	case 4:
	  exit (0);
	default:
	  printf ("\nWRONG OPTION");
	}
    }
  return 0;
}

10)
     Implement Insert, Delete and Display operations on circular
       Singly Linked List with header node.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *link;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMORY\n");
      exit (0);
    }
  return x;
}

NODE insert_front (int item, NODE head)
{
  NODE temp, first;
  temp = getnode ();
  temp->info = item;
  first = head->link;
  head->link = temp;
  temp->link = first;
  return head;
}

NODE insert_rear (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  cur = head->link;
  while (cur->link != head)
    {
      cur = cur->link;
    }
  cur->link = temp;
  temp->link = head;
  return head;
}

NODE delete_rear (NODE head)
{
  NODE prev, cur;
  if (head->link == head)
    {
      printf ("List is empty\n");
      return head;
    }
  cur = head->link;
  prev = head;
  while (cur->link != head)
    {
      prev = cur;
      cur = cur->link;
    }
  prev->link = head;
  printf ("The item deleted is %d\n", cur->info);
  free (cur);
  return head;
}

NODE delete_front (NODE head)
{
  NODE first, second;
  if (head->link == head)
    {
      printf ("List is empty\n");
      return head;
    }
  first = head->link;
  second = first->link;
  head->link = second;
  printf ("The item deleted is %d\n", first->info);
  free (first);
  return head;
}

void display (NODE head)
{
  NODE temp;
  {
    if (head->link == head)
      {
	printf ("List is empty\n");
	return;
      }
    printf ("The contents of singly linked listl\n");
    temp = head->link;
    while (temp != head)
      {
	printf ("%d ", temp->info);
	temp = temp->link;
      }
  }
}

void main ()
{
  NODE head;
  int choice, item;
  head = getnode ();
  head->link = head;
  for (;;)
    {
      printf ("1:Insert_Front 2:insert_rear\t");
      printf ("3:delete_front\t 4:delete_rear\t 5.exit\n");
      printf ("Enter the choice\n");
      scanf ("%d", &choice);
      switch (choice)
	{
	case 1:
	  printf ("Enter the item to be inserted in\n");
	  scanf ("%d", &item);
	  head = insert_front (item, head);
	  break;
	case 2:
	  printf ("Enter the item to be inserted in\n");
	  scanf ("%d", &item);
	  head = insert_rear (item, head);
	  break;
	case 3:
	  head = delete_front (head);
	  break;
	case 4:
	  head = delete_rear (head);
	  break;
	case 5:
	  display (head);
	  break;
	default:
	  exit (0);
	}
    }
}

12)
     Implement Insert, Delete and Display operations on Doubly Linked List.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *rlink;
       struct node *llink;
     };

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMORY\n");
      exit (0);
    }
  return x;
}

NODE insertfront (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == NULL)
    {
      head->rlink = temp;
      temp->llink = head;
      temp->rlink = NULL;
      head->llink = NULL;
      return head;
    }
  else
    {
      cur = head->rlink;
      temp->rlink = cur;
      head->rlink = temp;
      cur->llink = temp;
      temp->llink = head;
      return head;
    }
}

NODE insertrear (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == NULL)
    {
      head->rlink = temp;
      head->llink = NULL;
      temp->rlink = NULL;
      temp->llink = head;
      return head;
    }
  cur = head->rlink;
  while (cur->rlink != NULL)
    {
      cur = cur->rlink;
    }
  cur->rlink = temp;
  temp->rlink = NULL;
  temp->llink = cur;
  head->llink = NULL;
  return head;
}

NODE delfront (NODE head)
{
  NODE temp, cur;
  if (head->rlink == NULL)
    {
      printf ("LIST IS EMPTY \n");
      return head;
    }
  temp = head->rlink;
  cur = temp->rlink;
  if (cur == NULL)
    {
      head->rlink = NULL;
    }
  else
    {
      head->rlink = cur;
      cur->llink = head;
    }
  printf ("DELETED ITEM =%d\n", temp->info);
  free (temp);			//FREEING MEMORY
  return head;
}

NODE delrear (NODE head)
{
  NODE temp, cur;
  if (head->rlink == NULL)
    {
      printf ("LIST IS EMPTY\n");
      return head;
    }
  else
    {
      temp = head->rlink;
      while (temp->rlink != NULL)
	{
	  temp = temp->rlink;
	}
      if (temp->llink == head)
	head->rlink = NULL;
      else
	{
	  cur = temp->llink;
	  cur->rlink = NULL;
	  head->llink = NULL;
	}
      printf ("DELETED ITEM =%d\n", temp->info);
      free (temp);
      return head;
    }
}

void display (NODE head)
{
  NODE temp;
  if (head->rlink == NULL)
    {
      printf ("LIST IS EMPTY\n");
    }
  else
    {
      temp = head->rlink;
      while (temp != NULL)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
    }
  printf ("\n");
}

int main ()
{
  int ch, item;
  NODE head = getnode ();
  head->info = NULL;
  head->rlink = NULL;
  head->llink = NULL;
  while (1)
    {
      printf
	("1.Insert Front 2.Insert Rear 3.Delete Front 4.Delete Rear 5.Display
6.Exit\n");
      printf ("ENTER YOUR CHOICE\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertfront (item, head);
	  break;
	case 2:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertrear (item, head);
	  break;
	case 3:
	  head = delfront (head);
	  break;
	case 4:
	  head = delrear (head);
	  break;
	case 5:
	  display (head);
	  break;
	case 6:
	  exit (0);
	  break;
	default:
	  printf ("INVALID CHOICE!!TRY AGAIN\n");
	  break;
	}
    }
  return 0;
}

12 Implement Insert, Delete and Display operations on Circular Doubly Linked
  List.
#include <stdio.h> #include
< stdlib.h > struct node
{
  int info;
  struct node *rlink;
  struct node *llink;
};

typedef struct node *NODE;
NODE getnode ()
{
  NODE x;
  x = (NODE) malloc (sizeof (struct node));
  if (x == NULL)
    {
      printf ("OUT OF MEMORY\n");
      exit (0);
    }
  return x;
}

NODE insertfront (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == head)
    {
      head - >rlink = temp;
      temp->llink = head;
      temp->rlink = head;
      head->llink = temp;
      return head;
    }
  else
    {
      cur = head->rlink;
      temp - >rlink = cur;
      head->rlink = temp;
      cur->llink = temp;
      temp->llink = head;
      return head;
    }
}

NODE insertrear (int item, NODE head)
{
  NODE temp, cur;
  temp = getnode ();
  temp->info = item;
  if (head->rlink == head)
    {
      head->rlink = temp;
      head->llink = temp;
      temp->rlink = head;
      temp->llink = head;
      return head;
    }
  cur = head - >llink;
  cur - >rlink = temp;
  temp - >rlink = head;
  temp - >llink = cur;
  head->llink = temp;
  return head;
}

NODE delfront (NODE head)
{
  NODE temp, cur;
  if (head->rlink == head)
    {
      printf ("LIST IS EMPTY \n");
      return head;
    }
  temp = head->rlink;
  cur = temp->rlink;
  if (cur == head)
    {
      head->rlink = head;
    }
  else
    {
      head->rlink = cur;
      cur->llink = head;
    }
  printf ("DELETED ITEM =%d\n", temp->info);
  free (temp);
  return head;
}

NODE delrear (NODE head)
{
  NODE temp, cur;
  if (head->rlink == head)
    {
      printf ("LIST IS
EMPTY\n");
      return head;
    }
  else
    {
      temp = head->llink;
      if (temp->llink == head)
	head->rlink = head;
      else
	{
	  cur = temp->llink;
	  cur->rlink = head;
	  head->llink = cur;
	}
      printf ("DELETED ITEM =%d\n", temp->info);
      free (temp);
      return head;
    }
}

void display (NODE head)
{
  NODE temp;
  if (head->rlink == head)
    {
      printf ("LIST IS EMPTY\n");
    }
  else
    {
      temp = head->rlink;
      while (temp != head)
	{
	  printf ("%d ", temp->info);
	  temp = temp->rlink;
	}
    }
  printf ("\n");
}

int main ()
{
  int ch, item;
  NODE head = getnode ();
  head->info = NULL;
  head->rlink = head;
  head->llink = head;
  while (1)
    {
      printf
	("1.Insert Front 2.Insert Rear 3.Delete Front 4.Delete Rear 5.Display 6.Exit\n");
      printf ("ENTER YOUR CHOICE\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertfront (item, head);
	  break;
	case 2:
	  printf ("ENTER THE ITEM\n");
	  scanf ("%d", &item);
	  head = insertrear (item, head);
	  break;
	case 3:
	  head = delfront (head);
	  break;
	case 4:
	  head = delrear (head);
	  break;
	case 5:
	  display (head);
	  break;
	case 6:
	  exit (0);
	  break;
	default:
	  printf ("INVALID CHOICE!!TRY AGAIN\n");
	  break;
	}
    }
  return 0;
}

13)
     Construct a Binary Search Tree and traverse it using In order,
       Preorder and Post order traversals.
#include <stdio.h>
#include <stdlib.h>
     struct node
     {
       int info;
       struct node *left;
       struct node *right;
     };

typedef struct node *NODE;
NODE insert (NODE r, int item)
{
  if (r == NULL)
    {
      r = (NODE) malloc (sizeof (struct node));
      r->info = item;
      r->left = NULL;
      r->right = NULL;
    }
  else if (item < r->info)
    r->left = insert (r->left, item);
  else
    r->right = insert (r->right, item);
  return r;
}

void preorder (NODE root)
{
  if (root == NULL)
    return;
  printf ("%d ", root->info);
  preorder (root->left);
  preorder (root b right);
}

void inorder (NODE root)
{
  if (root == NULL)
    return;
  inorder (root->left);
  printf ("%d ", root->info);
  Inorder (root->right);
}

void postorder (NODE root)
{
  if (root == NULL)
    return;
  postorder (root->left);
  postorder (root->right);
  printf ("%d ", root->info);
}

NODE search (NODE root, int item)
{
  NODE cur;
  if (root == NULL)
    {
      printf ("EMPTY TREE\n");
      return;
    }
  else
    {
      cur = root;
      while (cur != NULL)
	{
	  if (item == cur->info)
	    return cur->info;
	  else if (item < cur->info)
	    cur = cur->left;
	  else
	    cur = cur->right;
	}
      return NULL;
    }
}

int main ()
{
  int ch, item, i, n, it, temp;
  NODE root;
  root = (NODE) malloc (sizeof (struct node));
  root = NULL;
  while (1)
    {
      printf
	("\n1.Insert 2.Preorder 3.Postorder 4.Inorder 5.Search 6.Exit\n");
      printf ("\nEnter The Choice\n");
      scanf ("%d", &ch);
      switch (ch)
	{
	case 1:
	  printf ("ENTER THE NO OF ELEMENTS\n");
	  scanf ("%d", &n);
	  for (i = 0; i < n; i++)
	    {
	      printf ("Enter The Item %d\n", i + 1);
	      scanf ("%d", &item);
	      root = insert (root, item);
	    }
	  break;
	case 2:
	  preorder (root);
	  break;
	case 3:
	  postorder (root);
	  break;
	case 4:
	  inorder (root);
	  break;
	case 5:
	  printf ("ENTER THE ELEMENT TO BE SEARCHED\n");
	  scanf ("%d", &it);
	  temp = search (root, it);
	  if (temp == NULL)
	    printf ("SEARCH UNSUCCESSFULL\n");
	  else
	    printf ("%d is found in the tree\n", temp);
	  break;
	case 6:
	  exit (0);
	  break;
	default:
	  printf ("WRONG CHOICE!! TRY AGAIN\n");
	}
    }
  return 0;
}

 </pre>
</body>
</html>
